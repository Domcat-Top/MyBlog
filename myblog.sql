/*
Navicat MySQL Data Transfer

Source Server         : test
Source Server Version : 50729
Source Host           : localhost:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50729
File Encoding         : 65001

Date: 2020-10-04 18:06:17
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `blogName` varchar(255) NOT NULL,
  `label` varchar(255) NOT NULL DEFAULT '管理员',
  `comeForm` varchar(255) NOT NULL DEFAULT '原创',
  `introduction` text NOT NULL,
  `blogContent` longtext NOT NULL,
  `url` text NOT NULL,
  `view` int(11) NOT NULL DEFAULT '1',
  `version` int(11) NOT NULL DEFAULT '1',
  `deleted` int(1) NOT NULL DEFAULT '0' COMMENT '默认0，未删除状态，1是已删除状态',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `label` (`label`),
  CONSTRAINT `blog_key_Fk` FOREIGN KEY (`label`) REFERENCES `foreignkey` (`label`) ON DELETE NO ACTION ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('1', '管理员测试1', '管理员', '原创', '管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员', '管理员测试文本输入！\r\n管理员测试文本输入！\r\n管理员测试文本输入！\r\n管理员测试文本输入！\r\n管理员测试文本输入！\r\n管理员测试文本输入！\r\n管理员测试文本输入！\r\n管理员测试文本输入！\r\n', 'https://w.wallhaven.cc/full/ey/wallhaven-eyl1xr.jpg', '6', '1', '0', '2020-09-08 16:38:52', '2020-09-09 10:58:13');
INSERT INTO `blog` VALUES ('13', '测试2', '测试类', '原创', '管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员', '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试', 'https://w.wallhaven.cc/full/4y/wallhaven-4yqz67.jpg', '1', '1', '0', '2020-09-16 15:16:22', '2020-09-16 15:16:22');
INSERT INTO `blog` VALUES ('14', '排错1', '排错类', '原创', '管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员测试6管理员', '排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错排错', 'https://w.wallhaven.cc/full/5w/wallhaven-5w26x1.jpg', '1', '1', '0', '2020-09-16 15:18:32', '2020-09-16 15:18:32');
INSERT INTO `blog` VALUES ('24', 'Markdown语法简介', 'Markdown', '转载', '<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。</p>\n', '# 欢迎使用 Cmd Markdown 编辑阅读器\r\n\r\n------\r\n\r\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\r\n\r\n> * 整理知识，学习笔记\r\n> * 发布日记，杂文，所见所想\r\n> * 撰写发布技术文稿（代码支持）\r\n> * 撰写发布学术论文（LaTeX 公式支持）\r\n\r\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\r\n\r\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\r\n\r\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\r\n\r\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\r\n\r\n------\r\n\r\n## 什么是 Markdown\r\n\r\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\r\n\r\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\r\n\r\n- [ ] 支持以 PDF 格式导出文稿\r\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\r\n- [x] 新增 Todo 列表功能\r\n- [x] 修复 LaTex 公式渲染问题\r\n- [x] 新增 LaTex 公式编号功能\r\n\r\n### 2. 书写一个质能守恒公式[^LaTeX]\r\n\r\n$$E=mc^2$$\r\n### 3. 高亮一段代码[^code]\r\n\r\n```python\r\n@requires_authorization\r\nclass SomeClass:\r\n    pass\r\n\r\nif __name__ == \'__main__\':\r\n    # A comment\r\n    print \'hello world\'\r\n```\r\n\r\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\r\n\r\n```flow\r\nst=>start: Start\r\nop=>operation: Your Operation\r\ncond=>condition: Yes or No?\r\ne=>end\r\n\r\nst->op->cond\r\ncond(yes)->e\r\ncond(no)->op\r\n```\r\n\r\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\r\n\r\n```seq\r\nAlice->Bob: Hello Bob, how are you?\r\nNote right of Bob: Bob thinks\r\nBob-->Alice: I am good thanks!\r\n```\r\n\r\n### 6. 高效绘制 [甘特图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图)\r\n\r\n```gantt\r\n    title 项目开发流程\r\n    section 项目确定\r\n        需求分析       :a1, 2016-06-22, 3d\r\n        可行性报告     :after a1, 5d\r\n        概念验证       : 5d\r\n    section 项目实施\r\n        概要设计      :2016-07-05  , 5d\r\n        详细设计      :2016-07-08, 10d\r\n        编码          :2016-07-15, 10d\r\n        测试          :2016-07-22, 5d\r\n    section 发布验收\r\n        发布: 2d\r\n        验收: 3d\r\n```\r\n\r\n### 7. 绘制表格\r\n\r\n| 项目        | 价格   |  数量  |\r\n| --------   | -----:  | :----:  |\r\n| 计算机     | \\$1600 |   5     |\r\n| 手机        |   \\$12   |   12   |\r\n| 管线        |    \\$1    |  234  |\r\n\r\n### 8. 更详细语法说明\r\n\r\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\r\n\r\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\r\n\r\n---\r\n## 什么是 Cmd Markdown\r\n\r\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\r\n\r\n### 1. 实时同步预览\r\n\r\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\r\n\r\n### 2. 编辑工具栏\r\n\r\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\r\n\r\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\r\n\r\n### 3. 编辑模式\r\n\r\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右侧的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\r\n\r\n### 4. 实时的云端文稿\r\n\r\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\r\n\r\n### 5. 离线模式\r\n\r\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\r\n\r\n### 6. 管理工具栏\r\n\r\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\r\n\r\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\r\n\r\n通过管理工具栏可以：\r\n\r\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\r\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\r\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\r\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\r\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\r\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\r\n\r\n### 7. 阅读工具栏\r\n\r\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\r\n\r\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\r\n\r\n工具栏上的五个图标依次为：\r\n\r\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\r\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\r\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\r\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\r\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\r\n\r\n### 8. 阅读模式\r\n\r\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\r\n\r\n### 9. 标签、分类和搜索\r\n\r\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\r\n\r\n标签： 未分类\r\n\r\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\r\n\r\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\r\n\r\n### 10. 文稿发布和分享\r\n\r\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\r\n\r\n------\r\n## 什么是 Cmd Markdown\r\n\r\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\r\n\r\n### 1. 实时同步预览\r\n\r\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\r\n\r\n### 2. 编辑工具栏\r\n\r\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\r\n\r\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\r\n\r\n### 3. 编辑模式\r\n\r\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右侧的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\r\n\r\n### 4. 实时的云端文稿\r\n\r\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\r\n\r\n### 5. 离线模式\r\n\r\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\r\n\r\n### 6. 管理工具栏\r\n\r\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\r\n\r\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\r\n\r\n通过管理工具栏可以：\r\n\r\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\r\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\r\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\r\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\r\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\r\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\r\n\r\n### 7. 阅读工具栏\r\n\r\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\r\n\r\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\r\n\r\n工具栏上的五个图标依次为：\r\n\r\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\r\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\r\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\r\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\r\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\r\n\r\n### 8. 阅读模式\r\n\r\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\r\n\r\n### 9. 标签、分类和搜索\r\n\r\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\r\n\r\n标签： 未分类\r\n\r\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\r\n\r\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\r\n\r\n### 10. 文稿发布和分享\r\n\r\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\r\n\r\n------\r\n\r\n', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1750208429,1514486128&fm=26&gp=0.jpg', '1', '1', '0', '2020-09-19 08:41:44', '2020-09-19 08:41:44');
INSERT INTO `blog` VALUES ('25', 'Redis学习笔记', '笔记', '转载', '<p>Redis是一个开源的，使用ANSI C 编写，高性能的Key-Value的NoSQL数据库。</p>\n', '### NoSQL能干嘛、是什么、怎么用？\r\n\r\n* NOSQL能干嘛:\r\n\r\n  * 多样灵活的数据模型NoSQL无需事先为要存储的数据建立字段，随时可以存储定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事请。若果是非常大数据量的表，增加字段简直就是一个噩梦\r\n  * 易扩展\r\n  * 大数据量高性能\r\n  * 传统RDBMS VS NOSQL\r\n* RDBMS\r\n  *  高度组织化结构化数据\r\n  *  结构化查询语言（SQL）\r\n  *  数据和关系都存储在单独的表中\r\n  *  数据操纵语言，数据定义语言\r\n  *  严格的一致性\r\n  *  基础事务\r\n* NoSQL\r\n  * 代表着不仅仅是SQL\r\n  * 没有声明性查询语言\r\n  * 没有预定的模式  \r\n  * 键-值对存储，列存储，文档存储，图形数据库\r\n  * 最终一致性，而非ACID属性\r\n  * 非结构化和不可预知的数据\r\n  * CAP定理\r\n  * 高性能，高可用性和伸缩性\r\n* NoSQL这盘棋去哪里下：\r\n  * Redis\r\n  * Memcache（强悍--缓存）\r\n  * Mongdb（最像关系型数据库的一种非关系型数据库）淘宝存商品信息评论的文档数据库 \r\n* 怎么玩：\r\n  * KV\r\n  * Cache\r\n  * Persistence \r\n* 3V+3 高\r\n  * 大数据时代的3V\r\n    * 海量 Volume\r\n    * 多样 Variety\r\n    * 实时 Velocity\r\n  * 互联网需求的3高\r\n    * 高并发\r\n    * 高可扩 （一定是指横向扩展）\r\n    * 高性能  \r\n * NoSQL怎么设计\r\n   * BSON\r\n     * 是一种json的一种二进制形式的存储格式，简称Binary JSON\r\n     * 和json一样，支持内嵌的文档对象和数组对象\r\n   * 用BSON  建立数据模型\r\n   * ![a1dee381fca73097baab18c4656cbf1c.png](en-resource://database/672:1)\r\n* NoSQL模型简介\r\n  *   KV键值\r\n  *   Bson\r\n  *   列族\r\n  *   图形\r\n* NoSQL数据库的四大分类\r\n  *   KV键值：景点介绍\r\n      *   新浪：BrekeyDB+redis\r\n      *   美团：redis+tair\r\n      *   阿里、百度：memcache+redis\r\n  *   文档型数据库（bson格式比较多）：典型介绍\r\n      *   CouchDB\r\n      *   MongoDB \r\n          *   基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案\r\n          *   介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的\r\n  *   列存储数据库\r\n      *   Cassandra， Hbase（哈杜泼的兄弟）\r\n      *   分布式文件系统\r\n  *   图关系数据库\r\n      *   它不是放图形的，放的是关系 比如：朋友圈社交网络、广告推荐系统\r\n      *   社交网络，推荐系统等。专注于构建关系图谱\r\n      *   Neo4J,InfoGrid\r\n  *   四者对比\r\n      *   \r\n\r\n| 分类              | Examples举例                                     | 典型应用场景                                                 | 数据类型                                      | 优点                                                         | 缺点                                                         |\r\n| ----------------- | ------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| 键值（Key-Value） | Tokyo、Cabinet/Tyrant\\Redis\\Vodemort、Oracle BDB | 内容缓存，主要用于出里大量数据的高访问量负载，也用于一些日志系统等 | key只想Value的键值对，通常用hash table 来实现 | 查找速度块                                                   | 数据五结构化，通常只被当作字符串或者二进制数据               |\r\n| 列存储数据库      | Cassandra、HBase、Riak                           | 分布式的文件系统                                             | 以列簇式存储，将同一列数据存在一起            | 查找速度快、可扩展性强，更易于进行分布式扩展                 | 功能相对局限                                                 |\r\n| 文档型数据库      | CouchDB、MongDB                                  | web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） | Key-Value对应的键值对，Value为结构化数据      | 数据结构要求不严格，表结构可变，不需要像关系数据库一样需要预先定义表结构 | 查询性能不高，而且缺乏统一的查询语句                         |\r\n| 图关系数据库      | Neo4J,InfoGrid、Infinite Graph                   | 社交网络，推荐系统等。专注于构建关系图谱                     | 图结构                                        | 利用图结构相关算法。比如：最短路径寻址，N度关系查找等        | 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的额集群方案 |\r\n\r\n* 在分布式数据库中CAP原理 CAP+BSASE\r\n  * 传统的关系型数据库：ACID\r\n    * A（Atomicity）原子性\r\n    * C（Consistency）一致性\r\n    * I（Isolation）独立性\r\n    * D（Durability）持久性\r\n  * NoSQL：CAP\r\n    * C:Consistency（强一致性）\r\n    * A:Availability（可用性）\r\n    * P: Partition tolerance（分区容错性）\r\n  * CAP 不可能全部满足 需要三选二：\r\n  * CAP核心：最多只能同时较好的满足两个\r\n    * CA：单点集群，满足一致性，可用性的系统，通常在可扩展上不太强大\r\n    * CP：满足一致性，分区容忍性的系统，通常性能不是特别高\r\n    * AP: 满足可用性，分区容忍性的系统，通常可能对一致性的要求低一些 （一半用这个）\r\n  * BASE：为了解决关系数据库强一致性引起的问题而引起的可用性降低而题除的解决方案\r\n    * 基本可用 （Basically Available）\r\n    * 软状态 （Soft state）\r\n    * 最终一致 （Eventually consistent）\r\n  * 分布式+集群简介 \r\n    * 分布式：不同的多台服务器上面部署不同的服务模块(工程)，他们之间通过Rpc/Rmi之间通.信和调用，对外提供服务和组内协作。\r\n    * 集群:不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统- -的调度，对外提供服务和访问。\r\n\r\n### Redis入门介绍\r\n\r\n* Redis是什么: Redis:Remote Dictionary Server(远程字典服务器)\r\n  * 完全开源免费的，用C语言编写的，遵守BSD协议\r\n  * 是一个高性能（Key/Value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当下最热门的NoSQL数据库之一，也被人们称为数据结构服务器\r\n  * Redis与其他kry-value 缓存产品有一下三个特点\r\n    * Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用\r\n    * Redis不仅仅支持简单的key-value类型的数据，同时嗨提供list，set，zset，hash等数据结构的存储\r\n    * Redis支持数据的备份，即master-slave模式的数据备份\r\n* Redis能干嘛：\r\n  * 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务\r\n  * 取最新N个数据的操作\r\n  * 模拟类似于HttpSession这种需要设定过期时间的功能\r\n  * 定时器、计数器\r\n* Redis下载：英文：Http//redis.io/ 中文：http：//www.redis.cn/\r\n* Redis怎么玩：\r\n  * 数据类型、基本操作和配置\r\n  * 持久化和复制，RDB/AOF\r\n  * 事务的控制\r\n  * 复制\r\n  * ......\r\n * 企业里边做开发，99%都是Linux班的运用和安装，几乎不会涉及到WIndows版。 \r\n\r\n### Redis 安装\r\n\r\n- 前提：Redis是c语言编写的所以需要 Gcc环境 预先装好gcc\r\n- 直接 干上下载地址就完事了：wget http://download.redis.io/releases/redis-5.0.4.tar.gz\r\n- 下载好解压：tar -zxvf redis-5.0.4.tar.gz\r\n- 解压后修改一下配置文件\r\n- 然后运行就完事了 \r\n- 查看进程：ps -ef|grep redis\r\n\r\n### Redis启动后杂项基础知识\r\n\r\n- 单进程\r\n  - 单进程模型来处理客户端的请求，对读写等事件的响应 通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率\r\n  - Epoll是Linux内核为处理大批量文件描述符而做了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，他能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率\r\n- 默认16个数据库，类似数组下表从零开始，初始默认使用零号库\r\n- Select命令切换数据库 ：select 7 对应八号库\r\n- Dbsize查看当前数据库的key的数量\r\n  - keys * 查看当前库所有key\r\n- Flushdb：清空当前库\r\n- Flushall：通杀全部库\r\n- 同意密码管理，16个库都是同样密码，要么OK要么一个也连不上\r\n- Redis索引都是从零开始\r\n- 为什么默认端口是6379\r\n\r\n### Redis的五大数据类型\r\n\r\n\r\n\r\n[指令参考（API文档）]: http://redisdoc.com/\r\n\r\n#### key关键字\r\n\r\n- keys*  查看所有key\r\n- exist key 的名字，判断某个key是否存在（1存在 0不存在）\r\n- move key db -->当前库就没有了，被移除了\r\n- expire key秒钟：给定的key设置过期时间\r\n- ttl key 查看还有多少秒过期（-1永不过期，-2已过期） **过期死亡（意思为过期即删除该数据）**\r\n- type key 查看你的key是什么类型\r\n\r\n| 常用                    | 备注                                              |\r\n| ----------------------- | ------------------------------------------------- |\r\n| DEL key                 | 在key存在时删除key                                |\r\n| DUMP key                | 序列化给定key，并返回被序列化的值                 |\r\n| EXISTS key              | 检查给定的key是否存在                             |\r\n| EXPIRE key              | 给key设置过期时间，设置的时间单位为秒             |\r\n| EXIPIREAT key timestamp | 和 EXPIRE的作用一样，只不过设置的时间单位时时间戳 |\r\n| KETYS pattern           | 查找所有给定模式的key                             |\r\n| MOVE key db             | 将key移到几号库中                                 |\r\n| PERSIST key             | 移除key的过期时间，key将持久保存                  |\r\n| PTTL  key               | 以毫秒为单位返回key的生于的过期时间               |\r\n| TTL key                 | 以秒为单位返回key的生于的过期时间                 |\r\n| RANDOMKEY               | 从当前数据库中随机返回一个key                     |\r\n| RENAME key newkey       | 修改key的名称                                     |\r\n| RENAMENX key newkey     | 当newkey不存在是将key改名为newkey                 |\r\n| TYPE key                | 返回key所存储值的类型                             |\r\n\r\n\r\n\r\n#### 字符串（String）\r\n\r\n- String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value\r\n- String类型是二进制安全的，意思时redis的string可以包含任何数据。比如jpg图片或者序列化的对象\r\n- String类型是Redis最基本的数据类型，一个redis中字符串value最多可以是**512M**\r\n\r\n**常用操作**\r\n\r\n| 常用                                               | 备注                                                         |\r\n| -------------------------------------------------- | ------------------------------------------------------------ |\r\n| Incr/decr/incrby/decrby                            | 前提时数字的情况下才能用（incr/decr自增一  incrby+数字 增加多少 decrby+数字 减少多少） |\r\n| getrange/setrange                                  | 相当于截取 getrange k3 0 -1 意为从下标0开始读取到-1截止      |\r\n| setex（set with expire）/setnx（set if not exist） | set k1 10 v1 设置k1 v1键值对 时间是10秒 setnx  k1 v1 会失败因为k1存在 |\r\n| mset/mget/msetnx                                   | 设置、获取多个kv   msetnx ：**key友谊的小船说翻就全翻了**    |\r\n| getset                                             | 先get再set                                                   |\r\n\r\n\r\n\r\n#### 哈希（Hash类似java里的Map）\r\n\r\n- Redis hash是一个键值对的集合\r\n- Redis hash是一个String类型的field和value的映射表，hash特别适合用于存储对象\r\n- 类似于Java里面的Map<String, Object>\r\n- KV模式不变，但V是一个键值对\r\n\r\n* \r\n\r\n| 常用                               | 备注                                        |\r\n| ---------------------------------- | ------------------------------------------- |\r\n| hset/hget/hmset/hmget/hgetall/hdel | 添加/获取/添加多个/获取多个/全部获取/删除   |\r\n| hlen                               | 获取hash长度                                |\r\n| hexists key key里边的某个key       | 查看是否有某个key                           |\r\n| hkeys/hvals                        | 获取key里边所有的key/获取key里边所有的value |\r\n| hincrby/hincrbyfloat               | 增加/浮点增加                               |\r\n| hsetnx                             | 不存在往里边灌                              |\r\n\r\n#### 列表（List）\r\n\r\n- Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边或者尾部（右边），\r\n- 它的底层实际就是个链表）\r\n\r\n操作\r\n\r\n* 单值多value\r\n\r\n| 常用                           | 备注                                                         |\r\n| ------------------------------ | ------------------------------------------------------------ |\r\n| ipush/rpush/lrange             | ipush相当于队列 rpush相当于栈  **lrange list01 0 -1**        |\r\n| lpop/rpop                      | 取栈顶、栈尾数据 **取出去就没了**                            |\r\n| lindex                         | **lindex list01 0**  索引下标 拿值                           |\r\n| llen                           | 获取集合长度  **llen list01**                                |\r\n| lrem key                       | 删N个**value  lrem list01 2 3：**删除集合中两个值为3的数     |\r\n| ltrim key 开始 index 结束index | 截取指定范围的值后再赋值给key **LTRIM list01 0 2** 意为节去list01 2之后的数据给截断 不要了 |\r\n| linsert key befor/after值1 值2 | 在key中值1前后插入值2 linsert list02  befor 8 java：在list02中值为8的前边 |\r\n\r\n性能总结：\r\n\r\n* 它是一个字符串链表、left、right都可以插入添加\r\n* 如果键不存在，创建新的链表\r\n* 如果键已存在，新增内容\r\n* 如果值全部移除，对应的键也就消失啦\r\n* 链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了\r\n\r\n#### 集合（Set）\r\n\r\n- Redis的Set是String类型的无序集合。ta是通过HashTable实现的\r\n\r\n操作\r\n\r\n* 单值多value\r\n* 添加重复元素会自动消除 但是不会报错\r\n\r\n| 常用                               | 备注                                                         |\r\n| ---------------------------------- | ------------------------------------------------------------ |\r\n| sadd/smembers/sismember            | isadd增加set smembers set01查看 set sismember k 判断k是否在set中 |\r\n| scard                              | 获取集合元素个数                                             |\r\n| srem key value                     | 删除集合中值为value的元素                                    |\r\n| srandmember key                    | 在某个key中随机出几个                                        |\r\n| spop key                           | 随机出栈                                                     |\r\n| smove key1 key2 在key1里边的某个值 | 将key1里边的某个值赋值给key2                                 |\r\n| 差：sdiff 交：sinter  并：sunion   | 数学集合类（交并差）                                         |\r\n\r\n性能总结：\r\n\r\n#### 有序集合Zset（sorted set）\r\n\r\n- Redis zsrt和set一样是String类型元素的集合，且不允许重复的成员\r\n- 不同的是每个元素都会关联一个double类型的分数\r\n- redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数（score）却可以重复\r\n- 在set基础上，加一个score值\r\n  - 之前set是 k1 v1 v2 v3\r\n  - 现在zset是k1 score1 v1 score2 v2\r\n\r\n| 常用                               | 备注                                                         |\r\n| ---------------------------------- | ------------------------------------------------------------ |\r\n| sadd/smembers/sismember            | isadd增加set smembers set01查看 set sismember k 判断k是否在set中 |\r\n| scard                              | 获取集合元素个数                                             |\r\n| srem key value                     | 删除集合中值为value的元素                                    |\r\n| srandmember key                    | 在某个key中随机出几个                                        |\r\n| spop key                           | 随机出栈                                                     |\r\n| smove key1 key2 在key1里边的某个值 | 将key1里边的某个值赋值给key2                                 |\r\n| 差：sdiff 交：sinter  并：sunion   | 数学集合类（交并差）                                         |\r\n\r\n### Redis配置文件 redis.conf\r\n\r\n* 在linux上做开发 配置>开发 永远要把原始的配置文件备份一份\r\n\r\n* untis单位\r\n\r\n* ```\r\n  # 1k => 1000 bytes\r\n  \r\n  # 1kb => 1024 bytes\r\n  \r\n  # 1m => 1000000 bytes\r\n  \r\n  # 1mb => 1024*1024 bytes\r\n  \r\n  # 1g => 1000000000 bytes\r\n  \r\n  # 1gb => 1024*1024*1024 bytes\r\n  ```\r\n\r\n  缓存写满处理：\r\n\r\n  * volatile-lru:使用LRU算法移除key，只对设置了过期时间的键\r\n  * allkeys-lru：使用LRU算法一处key\r\n  * volatile-random：在集合中移除随机的key，只对设置了过期时间的键\r\n  * allkeys-random：移除随机的key\r\n  * volatile-ttl：移除那些TTL最小的key，即那些最近要过期的key\r\n  * noeviction：不进行移除。针对写操作，只是返回错误信息\r\n\r\n* redis.conf配置项说明如下:\r\n\r\n  1 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\r\n\r\n  daemonize no\r\n\r\n  2.当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件， 可以通过pidfile指定\r\n  pidfile /var/run/redis.pid]\r\n\r\n  3.指定Redis监听端口，默认端口为6379,作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\r\n  port 6379\r\n\r\n  4.绑定的主机地址\r\n  bind 127.0.0.1\r\n\r\n  5.当客户端闲置多长时间后关闭连接，如果指定为0,表示关闭该功能\r\n  timeout 300\r\n\r\n  6.指定日志记录级别，Redis.总共 支持四个级别: debug、 verbose、 notice、 warning, 默认为verbose\r\n  loglevel verbose\r\n\r\n  7.日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\r\n  logfile stdout\r\n\r\n  8.设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id\r\n  databases 16\r\n\r\n  9.指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\r\n  save <seconds> <changes>\r\n  Redis默认配置文件中提供了三个条件:\r\n  save 900 1\r\n  save 300 10\r\n  save 60 10000\r\n  分别表示900秒(15分钟)内有1个更改，300秒(5分钟)内有10个更改以及60秒内有10000个更改。\r\n\r\n  10.指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩， 如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\r\n  rdbcompression yes\r\n\r\n  11.指定本地数据库文件名，默认值为dump.rdb\r\n\r\n  12.指定本地数据库存放目录\r\n  dir :I|1\r\n\r\n  13.设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\r\n  slaveof <masterip> <masterport>\r\n\r\n  14.当master服务设置了密码保护时，slav服务连接master的密码\r\n  masterauth <master-password>\r\n\r\n  15.设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password> 命令提供密码，默认关闭\r\n  requirepass foobared\r\n\r\n  16.设置同一时间最大客户端连接数，默认无限制，Redis可 以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients 0,表示不作限\r\n\r\n  制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\r\n  maxclients 128\r\n\r\n  17.指定Redis最大内存限制，Redis在 启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\r\n  maxmemory <bytes>\r\n\r\n  18.指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致-段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。 默认为no\r\n\r\n  19.指定更新日志文件名，默认为appendonly .aof\r\n  appendfilename appendonly.aof\r\n\r\n  20.指定更新日志条件，共有3个可选值:\r\n  no: .表示等操作系统进行数据缓存同步到磁盘(快)\r\n  always:表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)\r\n  everysec:表示每秒同步一次(折衷，默认值)\r\n  appendfsync everysec\r\n\r\n### Redis 持久化\r\n\r\n* RDB（Redis DateBase）\r\n  * 是什么：Redis会单独创建(fork) 一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\r\n  * Fork：作用是复制-一个与当前进程一样的进程。新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\r\n  * SNAPSHOTTING快照：\r\n    * Save \r\n  * 动态停止RDB保存规则的方法：redis-cll config set save \" \"\r\n\r\n* AOF（Append Only one）\r\n  * appendonly ：yes 开启 no关闭\r\n  * appendfilename：名字 默认 qppendonly.aof\r\n  * Appendfsync：\r\n    * Always:同步持久化每次发生数据变更会被立即记录到磁盘性能较差但数据完整性比差\r\n    * Everysec:出厂默认推荐，异步操作，每秒记录如果一秒内宕机，有数据丢失\r\n    * No\r\n  * No-appendfsync-on-rewrite:重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。\r\n  * Auto-aof-rewrite-min-size:设置重写的基准值\r\n  * Auto-aof-rewrite-percentage:设置重写的基准值\r\n  * 检查修复：Redis-check-aof --fix进行修复\r\n  * AOF重写原理：文件持续增长而过大时，会fok出一条新进程来将文件重写，遍历新进程的内存中数据，每条记录有一条set语句。重写aof文件操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似\r\n  * 重写触发机制：Redis会记录上次重写时的AOF大小，默认配置时当AOF文件大小是上次rewrit后大小的一倍且文件大于64M时触发\r\n  * 小结：\r\n    * AOF文件时一个只进行追加的日志文件\r\n    * Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写\r\n    * AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松\r\n    * 对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积.\r\n    * 根据所使用的fsync策略，AOF的速度可能会慢于RDB\r\n\r\n* 两者可以和平共存  加载的时候先加载appendonly.aof然后zhao dump.rdb\r\n\r\n* RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储\r\n* AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末*尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大\r\n\r\n* 只做缓存:如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.|\r\n\r\n* 同时开启两种持久化方式\r\n* 性能建议：\r\n  * 因为RDB文件只用作后备用途，建议只在Slave.上持久化RDB文件，而且只要15分钟备份- -次就够了，只保留save 900 1这条规则。\r\n  * 如果Enalbe AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率， AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。\r\n  * 如果不Enable AOF，仅靠Master-Slave Replication实现高可用性也可以。能省掉- -大笔IO也减少了rewrite时带来的系统波\r\n    动。代价是如果Master/Slave同时倒掉， 会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新\r\n    的那个。新浪微博就选用了这种架构\r\n\r\n### Redis的事务（只能说对事务部分支持）\r\n\r\n- 是什么：可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会被序列化，按顺序地串行执行而不会被其他命令插入，不许加塞\r\n\r\n- 能干嘛：一个队列中，一次性、顺序性、排他性的执行一系列命令\r\n\r\n- 怎么用：\r\n\r\n  - 常用命令\r\n\r\n  | 序号 | 命令及描述                                                   |\r\n  | ---- | ------------------------------------------------------------ |\r\n  | 1    | DISCARD：取消事务，放弃事务块内的所有命令                    |\r\n  | 2    | EXEC：执行所有事务块内的命令                                 |\r\n  | 3    | MULTI：标记一个事务块的开始                                  |\r\n  | 4    | UNWATCH：取消WATCH命令对所有key的监控                        |\r\n  | 5    | WATCH key [key...] 监视一个（或多个）key，如果在执行之前这个（或这些）key被其他命令所改动，那么事务将被打断 |\r\n\r\n  * Case1：正常执行\r\n\r\n  - Case2：放弃事务\r\n  - Case3：全体连坐 直接报错\r\n  - Case4：冤头债主 正常加入队列不报错\r\n  - **Case5：watch监控**： 先监控后开启事务\r\n    - 乐观锁/悲观锁/CAS（Check And Set）\r\n      - 表锁（悲观锁）：有人修改时锁整张表。一致性极好 但是并发性不行\r\n        - 悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁\r\n      - 行锁（乐观锁）：会多个Version版本号，如果修改和拿到的版本号不一样 则需要重新修改 有人改 锁定改的行\r\n        - 乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断- -下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量I\r\n        - 乐观锁策略:提交版本必须大于记录当前版本才能执行更新\r\n    - 初始化信用卡可用余额和欠额\r\n    - 无加赛篡改，先监控在开启multi，保证两笔金额变动在一个事物内\r\n    - 有加塞篡改\r\n    - unwatch\r\n    - 一旦执行了exec之前加的监控锁都会被取消掉了\r\n    - 小结\r\n      - WATCH指令，类似乐观锁，事务提交时，如果key的值都已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行\r\n      - 通过WATCh 命令在事务执行之前监控了多个keys，倘若在WATCH之后有任何key值发生了变化，EXEC命令执行的事务都将被放弃，同时返回NUllmulti-bulk应答以通知调用者事务执行失败\r\n\r\n- 阶段\r\n\r\n  - 开启：以MULTI开始一个事务\r\n  - 入队：将多个命令入队到事务中，街道这些命令并不会立即执行，而是放到等待执行的事务的队列里边\r\n  - 执行：由EXEC命令触发事务\r\n\r\n- 特性\r\n\r\n  - 单独的隔离操作:事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断.\r\n  - 没有隔离级别的概念:队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题\r\n  - 不保证原子性: redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚\r\n\r\n### Redis的发布订阅\r\n\r\nps:（很少有人拿redis去订阅发布消息）\r\n\r\n* 是什么\r\n  * 进程间的一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息\r\n  * 订阅/发布\r\n* 命令\r\n* 案例:\r\n  * 先订阅后发布后才能收到消息，\r\n    1、可以一次性订阅多个，SUBSCRIBE c1 c2 e3\r\n    2、消息发布，PUBLISH c2 hello-redis\r\n    3、订阅多个，通配符*PSUBSCRIBE new*\r\n    4、收取消息，PUBL ISH new1 redis2015\r\n\r\n### Redis 主从复制\r\n\r\n* 是什么\r\n  * 也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主\r\n* 能干嘛\r\n  * 读写分离\r\n  * 容灾恢复\r\n* 怎么玩\r\n  * 配从（库）不配主（库）\r\n  * 从库配置：salveof 主库 IP 主库端口 eg:SALAVEOF 127.0.0.1 6379\r\n    * 每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件(从机死了 需要重新连接)\r\n    * Info replication\r\n  * 修改配置文件细节操作\r\n    * 拷贝多个redis.conf文件\r\n    * 开启daemonize yes\r\n    * Pid文件名字\r\n    * 指定端口\r\n    * Log文件名字\r\n    * Dump.rdb名字\r\n  * 常用\r\n    * 一主二仆：一个主机 两个仆机\r\n    * 薪火相传\r\n      * 上一个的Slave可以使下一个Slave的Master\r\n    * 反客为主：SLAVEOF  no one 使当前数据库停止与其他数据库的同步，转成主数据库\r\n* 复制原理：\r\n  * Slave启动成功连接到msater后会发送一个sync命令\r\n  * Master接到命令启动后台的存盘进程，同时手机所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，已完成一次完全同步\r\n  * 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内容中\r\n  * 增量复制：Master继续将新的所有收集到的修改命令个一次传给slave，完成同步\r\n  * 但是只要是重新连接 master，一次完全同步（全量复制）将被自动执行\r\n* 哨兵模式（sentinel）\r\n  * 是什么：反客为主的自动版\r\n  * 怎么玩：\r\n    * 自定义的/myredis目录下新建sentinel.conf文件，名字绝对不能错：touch sentinel.conf\r\n    * 配置哨兵，填写内容\r\n      * sentinel monitor 被监控主机名字（自己起名字） 127.0.0.1 6379 1\r\n      * 上面最后一个数字1，表示主机挂掉后salve投票看让谁接管成为新的主机\r\n    * 启动哨兵 \r\n    * 正常主从演示\r\n    * 原有的master挂了\r\n    * 投票新选\r\n    * 重新主从继续开工，info replication查查看\r\n    * 问题：如果之前的master回来 不会双master 会成为slave 跟这新的Msater干\r\n* 复制的缺点：\r\n  * 由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有-定的延迟，当系统很繁\r\n    忙的时候，延迟问题会更加严重，Slave机器 数量的增加也会使这个问题更加严重。\r\n\r\n', 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1775917842,1728091441&fm=26&gp=0.jpg', '1', '1', '0', '2020-09-19 08:48:52', '2020-09-19 08:48:52');
INSERT INTO `blog` VALUES ('26', 'Mybatis-plus一些常用操作', 'Mybatis-plus', '转载', '<p>Mybatis-plus是一个Mybatis的增强工具，只做增强，不做改变</p>\n', '### Mysql主键策略\r\n* 自动增长  AUTO INCREMENT ：分表时不方便\r\n* UUID：每次操作生成随机唯一的值 ：排序不方便\r\n* Redis实现：incr 实现\r\n* Mybatis-plus自动生成（长19位）\r\n* ID_WORKER:mp自带侧策略，生成19位值，数字类型使用这种策略 比如long\r\n* ID_WORKER_STR:mp自带侧策略，生成19位值，子字符串类型使用这种策略 比如String\r\n\r\n### mp实现自动填充\r\n* 不需要set到对象里边的值，使用mp的方式实现数据添加（比如不用手动添加时间）\r\n```java\r\n    @TableField(fill = FieldFill.INSERT)\r\n    private Date creatTime;\r\n    @TableField(fill =FieldFill.INSERT_UPDATE)\r\n    private  Date updateTime;\r\n```\r\n* 创建类，实现MetaObjectHandler，实现接口方法\r\n\r\n```java\r\npackage com.example.handler;\r\nimport com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;\r\nimport org.apache.ibatis.reflection.MetaObject;\r\nimport org.springframework.stereotype.Component;\r\nimport java.text.DateFormat;\r\nimport java.util.Date;\r\n\r\n@Component\r\npublic class MyMetaObjectHandler implements MetaObjectHandler {\r\n    DateFormat mediumDateFormat = DateFormat.getDateTimeInstance\r\n            (DateFormat.MEDIUM,DateFormat.MEDIUM);\r\n    // 添加填充\r\n    @Override\r\n    public void insertFill(MetaObject metaObject) { this.setFieldValByName(\"creatTime\",mediumDateFormat.format(new Date()),metaObject);\r\n        this.setFieldValByName(\"updateTime\",mediumDateFormat.format(new Date()),metaObject);\r\n    }\r\n    //修改填充\r\n    @Override\r\n    public void updateFill(MetaObject metaObject) {\r\n        this.setFieldValByName(\"updateTime\",mediumDateFormat.format(new Date()),metaObject);\r\n    }\r\n}\r\n```\r\n\r\n### 乐观锁\r\n* 主要解决丢失更新（通过version版本号来控制并发）\r\n* 表中添加version字段\r\n* 添加注解@Version配置插件\r\n```java\r\n@Configuration\r\npublic class MpConfig {\r\n    /**\r\n     * 乐观锁插件\r\n     * @return\r\n     */\r\n    @Bean\r\n    public OptimisticLockerInterceptor optimisticLockerInterceptor(){\r\n        return new OptimisticLockerInterceptor();\r\n    }\r\n}\r\n```\r\n### 多个ID批量查询\r\n```java\r\nuserMapper.selectBatchIds(Arrays.asList(\"id1\", \"id2\"));\r\n```\r\n### 分页查询（PageHelper类似）\r\n* 配置分页插件\r\n\r\n```java\r\n/**\r\n    * 分页插件\r\n    * @return\r\n    */\r\n   @Bean\r\n   public PaginationInterceptor paginationInterceptor(){\r\n       return new PaginationInterceptor();\r\n   }\r\n```\r\n* 编写分页代码 直接new page对象传入两个参数（当前页，每页显示记录数）\r\n\r\n```java\r\nPage<User>userPage=new Page<>(2,1);\r\n      userMapper.selectPage(userPage, null);\r\n      System.out.println(userPage.getCurrent());//获取当前页\r\n      System.out.println(userPage.getRecords());//每页数据list集合\r\n      System.out.println(userPage.getSize());//每页显示记录数\r\n      System.out.println(userPage.getTotal());//总记录数\r\n      System.out.println(userPage.getPages());//总页数\r\n      System.out.println(userPage.hasNext());//是否有下一页\r\n      System.out.println(userPage.hasPrevious());//是否有上一页\r\n```\r\n### 删除\r\n#### 物理删除\r\n* 根据id删除\r\n\r\n* 批量删除 mapper.deleteBatchIds(集合)\r\n\r\n#### 逻辑删除\r\n\r\n* 先加deleted字段\r\n* 加上@TableLogic注解\r\n* 加上配置\r\n\r\n```java\r\n    @Bean\r\n    public ISqlInjector sqlInjector(){\r\n        return new DefaultSqlInjector();\r\n    }\r\n```\r\n* 可设置默认值\r\n\r\n```xml\r\nmybatis-plus.global-config.db-config.logic-delete-value=1\r\nmybatis-plus.global-config.db-config.logic-not-delete-value=0\r\n```\r\n### 条件构造器\r\n* ge、gt、le、lt 大于等于，大于，小于等于，小于\r\n* eq、ne、等于，不等于\r\n* between 之间\r\n* like 模糊查询\r\n* last 拼接\r\n* select（列名字...）查询指定的列\r\n* orderByDES降序 orderESC升序\r\n* mp还提供了性能分析\r\n\r\n### mp代码生成器\r\n* 需要再引入依赖\r\n\r\n```xml\r\n<dependency>\r\n   <groupId>org.apache.velocity</groupId>\r\n   <artifactId>velocity-engine-core</artifactId>\r\n   <version>2.0</version>\r\n</dependency>\r\n```\r\n\r\n```java\r\npackage com.rw.utils;\r\nimport com.baomidou.mybatisplus.annotation.DbType;\r\nimport com.baomidou.mybatisplus.annotation.IdType;\r\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\r\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\r\nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;\r\nimport com.baomidou.mybatisplus.generator.config.PackageConfig;\r\nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;\r\nimport com.baomidou.mybatisplus.generator.config.rules.DateType;\r\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\r\nimport org.junit.Test;\r\n\r\n/**\r\n * @author\r\n * @since 2018/12/13\r\n */\r\npublic class CodeGenerator {\r\n\r\n    @Test\r\n    public void run() {\r\n\r\n        // 1、创建代码生成器\r\n        AutoGenerator mpg = new AutoGenerator();\r\n\r\n        // 2、全局配置\r\n        GlobalConfig gc = new GlobalConfig();\r\n        String projectPath = System.getProperty(\"user.dir\");\r\n        gc.setOutputDir(\"F:\\\\e\\\\SpringBoot-Vue-OnlineExam-master\\\\education_parent\\\\service\\\\service_edu\" + \"/src/main/java\");\r\n\r\n        gc.setAuthor(\"Ruiwen\");\r\n        gc.setOpen(false); //生成后是否打开资源管理器\r\n        gc.setFileOverride(false); //重新生成时文件是否覆盖\r\n\r\n        gc.setServiceName(\"%sService\");	//去掉Service接口的首字母I\r\n        gc.setIdType(IdType.ID_WORKER_STR); //主键策略\r\n        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型\r\n        gc.setSwagger2(true);//开启Swagger2模式\r\n\r\n        mpg.setGlobalConfig(gc);\r\n\r\n        // 3、数据源配置\r\n        DataSourceConfig dsc = new DataSourceConfig();\r\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/education?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\");\r\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\r\n        dsc.setUsername(\"root\");\r\n        dsc.setPassword(\"123456rw\");\r\n        dsc.setDbType(DbType.MYSQL);\r\n        mpg.setDataSource(dsc);\r\n\r\n        // 4、包配置\r\n        PackageConfig pc = new PackageConfig();\r\n        pc.setModuleName(\"eduservice\"); //模块名\r\n        pc.setParent(\"com.rw\");\r\n        pc.setController(\"controller\");\r\n        pc.setEntity(\"entity\");\r\n        pc.setService(\"service\");\r\n        pc.setMapper(\"mapper\");\r\n        mpg.setPackageInfo(pc);\r\n\r\n        // 5、策略配置\r\n        StrategyConfig strategy = new StrategyConfig();\r\n        // 根据表名生成实体类\r\n        strategy.setInclude(\"edu_course\",\"edu_course_description\",\"edu_chapter\",\"edu_video\");\r\n        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略\r\n        strategy.setTablePrefix(pc.getModuleName() + \"_\"); //生成实体时去掉表前缀\r\n\r\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略\r\n        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作\r\n\r\n        strategy.setRestControllerStyle(true); //restful api风格控制器\r\n        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符\r\n        mpg.setStrategy(strategy);\r\n\r\n        // 6、执行\r\n        mpg.execute();\r\n    }\r\n}\r\n\r\n```', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495133736,3955839624&fm=26&gp=0.jpg', '1', '1', '0', '2020-09-19 08:52:11', '2020-09-19 08:52:11');
INSERT INTO `blog` VALUES ('27', 'JSP九大内置对象详解', 'JSP', '转载', '<p>JSP（全称JavaServer Pages）是由Sun Microsystems公司主导创建的一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。</p>\n', '### JSP（动态网页，基于BS架构）\r\n- 不是和是否有“动感”混为一谈\r\n- 看网页是否会随时间、地点、用户操作的改变而改变\r\n### 两种架构（BS/CS）\r\nCS:\r\n- A、如果软件升级 所有(客户端)软件都需要升级\r\n- B、维护麻烦、需要维护每一台客户端软件\r\n- C、每一台客户端都需要安装客户端软件\r\nBS:\r\n- 客户端可以通过浏览器直接访问服务端\r\n**注意BS CS各有优势谁也不是谁的替代品 **\r\n### 九大内置对象\r\n#### 1、request\r\n- 含义：请求对象，存储“客户端向服务端发送的请求信息“\r\n\r\n| 常见方法  | 参数类型 | 返回值  |\r\n| ------------ | ------------ | ------------ |\r\n| getParameter（String name） |  key（input标签name的属性） |value   |\r\n| getParameterValues（String name）  | key（input标签name的属性）  |   String[]  多个value|\r\n|  SetCharacterEncoding (“编码格式utf-8”)|   默认（tomca7.0：“iso-8859-1“，8.0”utf-8“） |  Void |\r\n| getRequestDispatcher（”b.jsp”）.forward(request,response);   |  请求转发的页面 |  无 |\r\n| getServletContext（）  |  无 |  Object |\r\n#### 2、response响应对象\r\n| 常见方法  | 参数类型 | 返回值  |\r\n| ------------ | ------------ | ------------ |\r\n| ( 服务端向客户端增加cookie对象)addCookie(Cookie  cookid) | cookid |void   |\r\n| (重定向)sendRedirect(String location) throws IOException  | locationc重定向页面  |  void|\r\n| （设置编码格式）setContetType(String type)|   默认（tomca7.0：“iso-8859-1“，8.0”utf-8“） |  Void |\r\n**比较**\r\n\r\n|   |  请求转发 |重定向   |\r\n| ------------ | ------------ | ------------ |\r\n|   |  getRequestDispatcher（”b.jsp”）.forward(request,response); |   sendRedirect(String location) throws IOException;|\r\n| 地址栏是否改变  |  不变（check.jsp） |  改变(success.jsp) |\r\n| 是否保留第一次请求时的数据  | 保留  |  不保留 |\r\n| 请求的次数  | 1  | 2  |\r\n\r\n#### 3、session（服务端）会话对象\r\n ** Cookie（客户端，不是内置对象）需要new：Cookie是由服务端生成的，再发给客户端保存 相当于本地缓存： 客户端->服务端**\r\n \r\n| 常见方法  | 参数类型 | 返回值  |\r\n| ------------ | ------------ | ------------ |\r\n| 添加cookieaddCookie(Cookie  cookid)| cookid| void|\r\n|request.getCookies() |无 全部获取| 对象集|\r\n| String getName()  | 无  | 对应cookies[i]  |\r\n| String getValue()  |  无 |  对应cookies[i] |\r\n|  	Void setmaxAge(int expry毫秒) | expry毫秒  |  Void |\r\n\r\n服务端增加cookie：response对象 \r\n客户端获取cookie：request对象\r\n建议Cookie中只保存英文和数字否则需要编码和解码\r\n\r\n- 每次访问服务端都会产生一个session，为什么不会匹配错误呢 因为有JSESSIONID\r\n- 客户端第一次请求服务端时，服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象都会有一个唯一的sessionID（用去区分其他session），服务端会产生一个cookie，并且改cookie的name=JSESSIONID，vale=服务端的sessionid的值然后服务端会在响应客户端的同时将该cookie发送给客户端所以和护短就有了一个cookie（JSESSIONISD），这样客户端的cookie就可以和服务端的session一一对应了\r\n- 之后请求服务端是：服务端会先用客户端cookie的JSESSIONID去服务端的session中匹配sessionid，如果匹配成功，说明此用户不是第一次访问，就无需登陆\r\n- 强调：1、色的Dion存储在服务端 2、session实在同一个客户端（客户）请求时共享3、实现机制：在第一次客户请求时 产生一个sessionid并复制给cookie的jsessiod发给客户端\r\n**Session**\r\n\r\n| 常见方法  | 参数类型 | 返回值  |\r\n| ------------ | ------------ | ------------ |\r\n|  SetAtribute(KV) |  给session赋值 |   value|\r\n| getAtribute(K) | K  | value  |\r\n|  getID() |  获取sessionID |  String |\r\n|  setMaxInactiveInterval(秒)  | 设置最大有效 非活动时间  | void  |\r\n|   get MaxInactiveInterva(秒)  |  获取最大有效 非活动时间 |   int|\r\n\r\n**比较**\r\n\r\n|   | Session  | Cookie  |\r\n| ------------ | ------------ | ------------ |\r\n| 保存的位置  | 服务端  |   客户端|\r\n|  安全性 | 较安全  |  不安全 |\r\n|保存的内容  |  （String name，Object value） | （String name，String value）  |\r\n\r\n客户端在第一次请求服务端是如果服务端发现此请求没有JSESSIONID则会创建一个name=JSEESSIONID的cookie返回给客户端\r\n#### 4、application全局对象\r\n\r\n|  常见方法 | 参数类型  | 返回值  |\r\n| ------------ | ------------ | ------------ |\r\n|  getContexPath() | 无  |返回当前项目的虚拟路径   |\r\n| getRealPath( getContexPath() )  | 项目虚拟路径  | 返回项目绝对路径  |\r\n\r\n#### 5、pageContext  JSP页面容器\r\n#### 6、config  配置对象（服务器配置信息）\r\n#### 7、page   当前JSP页面对象（相当于java中的this）\r\n#### 8、Out  输出对象，向客户端输出内容\r\n#### 9、exeception 异常对象\r\n\r\n\r\n\r\n', 'https://w.wallhaven.cc/full/3k/wallhaven-3kp68d.jpg', '1', '1', '0', '2020-09-19 08:55:17', '2020-09-19 08:55:17');
INSERT INTO `blog` VALUES ('28', '常用pom依赖以及一些项目常用插件推荐', 'SpringBoot', '转载', 'Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。', '### Thymeleaf、MyBatis-plus 等常用pom引用\r\n\r\n#### Thymeleaf模板引擎\r\n```java\r\n<dependency>\r\n<groupId>org.springframework.boot</groupId>\r\n<artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n</dependency>\r\n```\r\n#### Thymleaf使用时需要加命名空间\r\n```\r\nxmlns:th=\"http://www.thymeleaf.org\"\r\n```\r\n#### 一些简单的基础用法\r\n```\r\n 语法规则：th：text：改变当前元素里面的文本内容；\r\nth：任意属性都可以用来替换原生属性的值 \r\n• 表达式：\r\n ${….} 获取变量的值   用的最多\r\n	获取对象属性\r\n	使用过内置的基本对象 eg：${session.foo}\r\n	内置的一些工具对象\r\n*{….}选择表达式 和${…}在功能上一样 \r\n 补充使用 配合th:object=\"${session.ser}\"\r\n #{…}获取国际化内容\r\n @{…..}定义URL的 	       \r\n ~{….}片段文档的表达式\r\n```\r\n#### MySQL、Mybatis-plus驱动包\r\n```java\r\n <dependency>\r\n    <groupId>mysql</groupId>\r\n    <artifactId>mysql-connector-java</artifactId>\r\n    <scope>8.0.17</scope>\r\n</dependency>\r\n<dependency>\r\n  <groupId>com.baomidou</groupId>\r\n  <artifactId>mybatis-plus-boot-starter</artifactId>\r\n  <version>3.2.0</version>\r\n</dependency>\r\n```\r\n#### Druid数据源\r\n```java\r\n<dependency>\r\n    <groupId>com.alibaba</groupId>\r\n    <artifactId>druid</artifactId>\r\n    <version>1.1.21</version>\r\n</dependency>\r\n```\r\n#### Druid yml配置写法：\r\n        druid:\r\n          initial-size: 5 # 连接池的初始化大小\r\n          min-idle: 10 #　最小空闲连接数\r\n          max-active: 20 #　最大空闲数\r\n          web-stat-filter:\r\n            exclusions: \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\" #不统计这些请求数据\r\n          stat-view-servlet: #　访问监控网页的登录用户名和密码\r\n            login-username: druid\r\n            login-password: druid\r\n\r\n#### Shiro安全框架\r\n```java\r\n<!--ShiroSubject用户SecurityManager管理所有用户Realm连接数据-->\r\n<dependency>\r\n	<groupId>org.apache.shiro</groupId>\r\n	<artifactId>shiro-spring</artifactId>\r\n	<version>1.4.1</version>\r\n</dependency>\r\n```\r\n#### logj日志框架\r\n\r\n```java\r\n<dependency>\r\n   <groupId>log4j</groupId>\r\n   <artifactId>log4j</artifactId>\r\n   <version>1.2.17</version>\r\n</dependency>\r\n```\r\n#### Shiro整合Thymleaf\r\n```java\r\n<dependency>\r\n    <groupId>com.github.theborakompanioni</groupId>\r\n    <artifactId>thymeleaf-extras-shiro</artifactId>     		<version>2.0.0</version>\r\n</dependency>\r\n```\r\n\r\n###2.项目中用到的一些插件网址\r\n\r\n[背景图片网址](https://www.toptal.com/designers/subtlepatterns/)\r\n\r\n[前端评论区模板](https://1.semantic-ui.com/views/comment.html )\r\n\r\n[编辑器：Markdown]( https://pandao.github.io/editor.md/)\r\n\r\n[内容排版：typo.css]( https://github.com/sofish/typo.css/)\r\n\r\n[代码高亮：prism]( https://github.com/PrismJS/prism)\r\n\r\n[滚动侦测：waypoints]( http://imakewebthings.com/waypoints/)\r\n\r\n[平滑滚动：jquery.scrolTo](https://github.com/flesler/jquery.scrollTo)\r\n[目录生成：Tocbot](https://tscanlin.github.io/tocbot/)\r\n\r\n[二维码生成：qrcode.js](https://davidshimjs.github.io/qrcodejs/)\r\n\r\n### 3.前端使用模板 Semantic UI \r\n#### 推荐：Layui、bootstrap', 'https://w.wallhaven.cc/full/76/wallhaven-76l1ev.jpg', '1', '1', '0', '2020-09-19 08:59:19', '2020-09-19 08:59:19');
INSERT INTO `blog` VALUES ('29', 'SpringBoot整合EasyExcel、swagger', 'SpringBoot', '转载', '<p>easyexcel 是一个 JAVA 解析 Excel 工具。在上层做了模型转换的封装，让使用者更加简单方便，性能更好\nSwagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>\n', '## EasyExcel\r\n### 1、引入easyexcel的pom依赖\r\n```xml\r\n<dependency>\r\n	<groupId>com.alibaba</groupId>\r\n	<artifactId>easyexcel</artifactId>\r\n	<version>2.2.3</version>\r\n</dependency>\r\n```\r\n### 2、配置监听\r\n#### 以添加树形一二级分类为例：\r\n```java\r\nimport com.alibaba.excel.context.AnalysisContext;\r\n\r\nimport com.alibaba.excel.event.AnalysisEventListener;\r\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\r\nimport com.rw.eduservice.entity.EduSubject;\r\nimport com.rw.eduservice.entity.excel.SubjectData;\r\nimport com.rw.eduservice.service.EduSubjectService;\r\nimport com.rw.serbase.exceptionhandler.MyException;\r\n\r\n\r\npublic class SubjectExcelListener extends AnalysisEventListener<SubjectData> {\r\n\r\n    //因为SubjectExcelListener不能交给spring进行管理，需要自己new，不能注入其他对象\r\n    //不能实现数据库操作\r\n    public EduSubjectService subjectService;\r\n    public SubjectExcelListener() {}\r\n    public SubjectExcelListener(EduSubjectService subjectService) {\r\n        this.subjectService = subjectService;\r\n    }\r\n\r\n    //读取excel内容，一行一行进行读取\r\n    @Override\r\n    public void invoke(SubjectData subjectData, AnalysisContext analysisContext) {\r\n        if(subjectData == null) {\r\n            throw new MyException(20001,\"文件数据为空\");\r\n        }\r\n\r\n        //一行一行读取，每次读取有两个值，第一个值一级分类，第二个值二级分类\r\n        EduSubject existOneSubject = this.existOneSubject(subjectService, subjectData.getOneSubjectName());\r\n        if(existOneSubject == null) { //没有相同一级分类，进行添加\r\n            existOneSubject = new EduSubject();\r\n            existOneSubject.setParentId(\"0\");\r\n            existOneSubject.setTitle(subjectData.getOneSubjectName());//一级分类名称\r\n            subjectService.save(existOneSubject);\r\n        }\r\n\r\n        //获取一级分类id值\r\n        String pid = existOneSubject.getId();\r\n\r\n        //添加二级分类\r\n        //判断二级分类是否重复\r\n        EduSubject existTwoSubject = this.existTwoSubject(subjectService, subjectData.getTwoSubjectName(), pid);\r\n        if(existTwoSubject == null) {\r\n            existTwoSubject = new EduSubject();\r\n            existTwoSubject.setParentId(pid);\r\n            existTwoSubject.setTitle(subjectData.getTwoSubjectName());//二级分类名称\r\n            subjectService.save(existTwoSubject);\r\n        }\r\n    }\r\n\r\n    //判断一级分类不能重复添加\r\n    private EduSubject existOneSubject(EduSubjectService subjectService,String name) {\r\n        QueryWrapper<EduSubject> wrapper = new QueryWrapper<>();\r\n        wrapper.eq(\"title\",name);\r\n        wrapper.eq(\"parent_id\",\"0\");\r\n        EduSubject oneSubject = subjectService.getOne(wrapper);\r\n        return oneSubject;\r\n    }\r\n\r\n    //判断二级分类不能重复添加\r\n    private EduSubject existTwoSubject(EduSubjectService subjectService,String name,String pid) {\r\n        QueryWrapper<EduSubject> wrapper = new QueryWrapper<>();\r\n        wrapper.eq(\"title\",name);\r\n        wrapper.eq(\"parent_id\",pid);\r\n        EduSubject twoSubject = subjectService.getOne(wrapper);\r\n        return twoSubject;\r\n    }\r\n\r\n    @Override\r\n    public void doAfterAllAnalysed(AnalysisContext analysisContext) {\r\n\r\n    }\r\n}\r\n```\r\n### 3、service中调用方法\r\n## swagger\r\n### 1、引入依赖\r\n```xml\r\n<!--swagger-->\r\n<dependency>\r\n     <groupId>io.springfox</groupId>\r\n     <artifactId>springfox-swagger2</artifactId>\r\n     <scope>provided </scope>\r\n</dependency>\r\n<dependency>\r\n     <groupId>io.springfox</groupId>\r\n     <artifactId>springfox-swagger-ui</artifactId>\r\n     <scope>provided </scope>\r\n</dependency>\r\n```\r\n###2、编写swagger配置\r\n```java\r\n\r\nimport com.google.common.base.Predicates;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport springfox.documentation.builders.ApiInfoBuilder;\r\nimport springfox.documentation.builders.PathSelectors;\r\nimport springfox.documentation.service.ApiInfo;\r\nimport springfox.documentation.service.Contact;\r\nimport springfox.documentation.spi.DocumentationType;\r\nimport springfox.documentation.spring.web.plugins.Docket;\r\n\r\n@Configuration\r\npublic class SwaggerConfig {\r\n    @Bean\r\n    public Docket webApiConfig() {\r\n\r\n        return new Docket(DocumentationType.SWAGGER_2)\r\n                .groupName(\"webApi\")\r\n                .apiInfo(webApiInfo())\r\n                .select()\r\n                .paths(Predicates.not(PathSelectors.regex(\"/admin/.*\")))\r\n                .paths(Predicates.not(PathSelectors.regex(\"/error.*\")))\r\n                .build();\r\n\r\n    }\r\n\r\n    private ApiInfo webApiInfo() {\r\n\r\n        return new ApiInfoBuilder()\r\n                .title(\"网站-课程中心API文档\")\r\n                .description(\"本文档描述了课程中心微服务接口定义\")\r\n                .version(\"1.0\")\r\n                .contact(new Contact(\"Ruiwen\", \"http://blog.rwbb.xyz\", \"1571187725@qq.com\"))\r\n                .build();\r\n    }\r\n}\r\n\r\n```\r\n### 3、加载配置文件\r\n* 在配置文件中加上@EnableSwagger2注解\r\n* 或者在启动类上加上@EnableSwagger2\r\n### 4、默认访问页面 \r\n访问地址栏后边加/swagger-ui.html\r\n\r\n', 'https://w.wallhaven.cc/full/ey/wallhaven-eywzkw.png', '1', '1', '0', '2020-09-19 09:02:33', '2020-09-19 09:02:33');
INSERT INTO `blog` VALUES ('30', '构建SpringCloud和SpringBoot项目常用的pom依赖', 'SpringBoot', '转载', '<p>以上是博主在做项目时常用的依赖，供大家参考。</p>\n', '## 1、构建SpringCloud框架\r\n### 父工程下需要的基本常用依赖（以Boot:2.2.2.RELEASE Cloud:Hoxton.RELEASE为例）\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <modules>\r\n        <module>service</module>\r\n        <module>common</module>\r\n    </modules>\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.2.2.RELEASE</version>\r\n        <relativePath/> <!-- lookup parent from repository -->\r\n    </parent>\r\n    <groupId>com.rw</groupId>\r\n    <artifactId>education_parent</artifactId>\r\n    <packaging>pom</packaging>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <name>education_parent</name>\r\n    <description>Demo project for Spring Boot</description>\r\n    <properties>\r\n        <java.version>1.8</java.version>\r\n        <guli.version>0.0.1-SNAPSHOT</guli.version>\r\n        <mybatis-plus.version>3.0.5</mybatis-plus.version>\r\n        <velocity.version>2.0</velocity.version>\r\n        <swagger.version>2.7.0</swagger.version>\r\n        <aliyun.oss.version>3.8.1</aliyun.oss.version>\r\n        <jodatime.version>2.10.3</jodatime.version>\r\n        <poi.version>3.1.7</poi.version>\r\n        <commons-fileupload.version>1.3.1</commons-fileupload.version>\r\n        <commons-io.version>2.6</commons-io.version>\r\n        <httpclient.version>4.5.1</httpclient.version>\r\n        <jwt.version>0.7.0</jwt.version>\r\n        <aliyun-java-sdk-core.version>4.3.3</aliyun-java-sdk-core.version>\r\n        <aliyun-sdk-oss.version>3.1.0</aliyun-sdk-oss.version>\r\n        <aliyun-java-sdk-vod.version>2.15.2</aliyun-java-sdk-vod.version>\r\n        <aliyun-java-vod-upload.version>1.4.11</aliyun-java-vod-upload.version>\r\n        <aliyun-sdk-vod-upload.version>1.4.11</aliyun-sdk-vod-upload.version>\r\n        <fastjson.version>1.2.28</fastjson.version>\r\n        <gson.version>2.8.2</gson.version>\r\n        <json.version>20170516</json.version>\r\n        <commons-dbutils.version>1.7</commons-dbutils.version>\r\n        <canal.client.version>1.1.0</canal.client.version>\r\n        <docker.image.prefix>zx</docker.image.prefix>\r\n        <cloud-alibaba.version>0.2.2.RELEASE</cloud-alibaba.version>\r\n        <spring-cloud-starter-alibaba-nacos-discovery.version>0.9.0.RELEASE</spring-cloud-starter-alibaba-nacos-discovery.version>\r\n    </properties>\r\n    <dependencyManagement>\r\n        <dependencies>\r\n            <dependency>\r\n                <groupId>org.springframework.cloud</groupId>\r\n                <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n                <version>${spring-cloud-starter-alibaba-nacos-discovery.version}</version>\r\n            </dependency>\r\n            <!--Spring Cloud-->\r\n            <dependency>\r\n                <groupId>org.springframework.cloud</groupId>\r\n                <artifactId>spring-cloud-dependencies</artifactId>\r\n                <version>Hoxton.RELEASE</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n\r\n            <dependency>\r\n                <groupId>org.springframework.cloud</groupId>\r\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\r\n                <version>${cloud-alibaba.version}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n            <!--mybatis-plus 持久层-->\r\n            <dependency>\r\n                <groupId>com.baomidou</groupId>\r\n                <artifactId>mybatis-plus-boot-starter</artifactId>\r\n                <version>${mybatis-plus.version}</version>\r\n            </dependency>\r\n\r\n            <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->\r\n            <dependency>\r\n                <groupId>org.apache.velocity</groupId>\r\n                <artifactId>velocity-engine-core</artifactId>\r\n                <version>${velocity.version}</version>\r\n            </dependency>\r\n\r\n            <!--swagger-->\r\n            <dependency>\r\n                <groupId>io.springfox</groupId>\r\n                <artifactId>springfox-swagger2</artifactId>\r\n                <version>${swagger.version}</version>\r\n            </dependency>\r\n            <!--swagger ui-->\r\n            <dependency>\r\n                <groupId>io.springfox</groupId>\r\n                <artifactId>springfox-swagger-ui</artifactId>\r\n                <version>${swagger.version}</version>\r\n            </dependency>\r\n\r\n            <!--aliyunOSS-->\r\n            <dependency>\r\n                <groupId>com.aliyun.oss</groupId>\r\n                <artifactId>aliyun-sdk-oss</artifactId>\r\n                <version>3.8.1</version>\r\n            </dependency>\r\n\r\n            <!--日期时间工具-->\r\n            <dependency>\r\n                <groupId>joda-time</groupId>\r\n                <artifactId>joda-time</artifactId>\r\n                <version>2.10.3</version>\r\n            </dependency>\r\n\r\n<!--            &lt;!&ndash;xls&ndash;&gt;-->\r\n<!--            <dependency>-->\r\n<!--                <groupId>org.apache.poi</groupId>-->\r\n<!--                <artifactId>poi</artifactId>-->\r\n<!--                <version>${poi.version}</version>-->\r\n<!--            </dependency>-->\r\n<!--            &lt;!&ndash;xlsx&ndash;&gt;-->\r\n<!--            <dependency>-->\r\n<!--                <groupId>org.apache.poi</groupId>-->\r\n<!--                <artifactId>poi-ooxml</artifactId>-->\r\n<!--                <version>${poi.version}</version>-->\r\n<!--            </dependency>-->\r\n\r\n            <!--文件上传-->\r\n            <dependency>\r\n                <groupId>commons-fileupload</groupId>\r\n                <artifactId>commons-fileupload</artifactId>\r\n                <version>${commons-fileupload.version}</version>\r\n            </dependency>\r\n\r\n            <!--commons-io-->\r\n            <dependency>\r\n                <groupId>commons-io</groupId>\r\n                <artifactId>commons-io</artifactId>\r\n                <version>${commons-io.version}</version>\r\n            </dependency>\r\n\r\n            <!--httpclient-->\r\n            <dependency>\r\n                <groupId>org.apache.httpcomponents</groupId>\r\n                <artifactId>httpclient</artifactId>\r\n                <version>${httpclient.version}</version>\r\n            </dependency>\r\n\r\n            <dependency>\r\n                <groupId>com.google.code.gson</groupId>\r\n                <artifactId>gson</artifactId>\r\n                <version>${gson.version}</version>\r\n            </dependency>\r\n\r\n            <!-- JWT -->\r\n            <dependency>\r\n                <groupId>io.jsonwebtoken</groupId>\r\n                <artifactId>jjwt</artifactId>\r\n                <version>${jwt.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>joda-time</groupId>\r\n                <artifactId>joda-time</artifactId>\r\n                <version>${jodatime.version}</version>\r\n            </dependency>\r\n\r\n            <!--aliyun-->\r\n            <dependency>\r\n                <groupId>com.aliyun</groupId>\r\n                <artifactId>aliyun-java-sdk-core</artifactId>\r\n                <version>${aliyun-java-sdk-core.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>com.aliyun.oss</groupId>\r\n                <artifactId>aliyun-sdk-oss</artifactId>\r\n                <version>${aliyun-sdk-oss.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>com.aliyun</groupId>\r\n                <artifactId>aliyun-java-sdk-vod</artifactId>\r\n                <version>${aliyun-java-sdk-vod.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>com.aliyun</groupId>\r\n                <artifactId>aliyun-java-vod-upload</artifactId>\r\n                <version>${aliyun-java-vod-upload.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>com.aliyun</groupId>\r\n                <artifactId>aliyun-sdk-vod-upload</artifactId>\r\n                <version>${aliyun-sdk-vod-upload.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>com.alibaba</groupId>\r\n                <artifactId>fastjson</artifactId>\r\n                <version>${fastjson.version}</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>org.json</groupId>\r\n                <artifactId>json</artifactId>\r\n                <version>${json.version}</version>\r\n            </dependency>\r\n\r\n            <dependency>\r\n                <groupId>commons-dbutils</groupId>\r\n                <artifactId>commons-dbutils</artifactId>\r\n                <version>${commons-dbutils.version}</version>\r\n            </dependency>\r\n\r\n            <dependency>\r\n                <groupId>com.alibaba.otter</groupId>\r\n                <artifactId>canal.client</artifactId>\r\n                <version>${canal.client.version}</version>\r\n            </dependency>\r\n        </dependencies>\r\n    </dependencyManagement>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n</project>\r\n\r\n```\r\n## 2、构建Springboot\r\n### 以Boot:2.2.2.RELEASE为例 依赖包括：JDBC Mybatis-plus redis lombox swagger\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n<modelVersion>4.0.0</modelVersion>\r\n<parent>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-parent</artifactId>\r\n    <version>2.2.2.RELEASE</version>\r\n    <relativePath/> <!-- lookup parent from repository -->\r\n</parent>\r\n<groupId>rwnb</groupId>\r\n<artifactId>admincontroller</artifactId>\r\n<version>0.0.1-SNAPSHOT</version>\r\n<name>demo</name>\r\n<description>Demo project for Spring Boot</description>\r\n\r\n<properties>\r\n    <java.version>1.8</java.version>\r\n</properties>\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <scope>8.0.17</scope>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.apache.velocity</groupId>\r\n        <artifactId>velocity-engine-core</artifactId>\r\n        <version>2.0</version>\r\n    </dependency>\r\n    <!--lombok用来简化实体类：需要安装lombok插件-->\r\n    <dependency>\r\n        <groupId>org.projectlombok</groupId>\r\n        <artifactId>lombok</artifactId>\r\n        <version>1.18.0</version>\r\n    </dependency>\r\n    <!--swagger-->\r\n    <dependency>\r\n        <groupId>io.springfox</groupId>\r\n        <artifactId>springfox-swagger2</artifactId>\r\n        <version>2.7.0</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>io.springfox</groupId>\r\n        <artifactId>springfox-swagger-ui</artifactId>\r\n        <version>2.7.0</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>com.baomidou</groupId>\r\n        <artifactId>mybatis-plus-boot-starter</artifactId>\r\n        <version>3.0.5</version>\r\n    </dependency>\r\n    <!-- redis -->\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-data-redis</artifactId>\r\n    </dependency>\r\n    <!-- spring2.X集成redis所需common-pool2-->\r\n    <dependency>\r\n        <groupId>org.apache.commons</groupId>\r\n        <artifactId>commons-pool2</artifactId>\r\n        <version>2.6.0</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-test</artifactId>\r\n        <scope>test</scope>\r\n        <exclusions>\r\n            <exclusion>\r\n                <groupId>org.junit.vintage</groupId>\r\n                <artifactId>junit-vintage-engine</artifactId>\r\n            </exclusion>\r\n        </exclusions>\r\n    </dependency>\r\n</dependencies>\r\n\r\n<build>\r\n    <plugins>\r\n        <plugin>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-maven-plugin</artifactId>\r\n        </plugin>\r\n    </plugins>\r\n</build>\r\n\r\n</project>\r\n\r\n```\r\n\r\n', 'https://w.wallhaven.cc/full/6k/wallhaven-6k3oox.jpg', '1', '1', '0', '2020-09-19 09:04:47', '2020-09-19 09:04:47');
INSERT INTO `blog` VALUES ('31', '十大经典排序算法', '常见手撕模板题', '转载', '<p>排序算法是《数据结构与算法》中最基本的算法之一。</p>\n<p>排序算法可以分为内部排序和外部排序。</p>\n<p>内部排序是数据记录在内存中进行排序。</p>', '| 排序算法  |平均时间复杂度   |最好情况|最坏情况|空间复杂度|排序方式|稳定性|\r\n| --- | --- | --- | --- | --- | --- | --- |\r\n|冒泡排序|O(n²)|O（n）|O(n²)|O（1）|ln-place|稳定|\r\n|选择排序|O(n²)|O(n²)|O(n²)|O（1）|ln-place|不稳定|\r\n|插入排序|O(n²)|O（n）|O(n²)|O（1）|ln-place|稳定|\r\n|希尔排序|O(n log n)|O(n log² n)|O(n log² n)|O（1）|ln-place|稳定|\r\n|归并排序|O(n log n)|O(n log n)|O(n log n)|O(n)|Out-place|不稳定|\r\n|快速排序|O(n log n)|O(n log n)|O(n²)|O(log n)|ln-place|不稳定|\r\n|堆排序|O(n log n)|O(n log n)|O(n log n)|O（1）|ln-place|不稳定|\r\n|计数排序|O(n+k)|O(n+k)|O(n+k)|O(K)|Out-place|稳定|\r\n|桶排序|O(n+k)|O(n+k)|O(n²)|O(n+k)|Out-place|稳定|\r\n|基数排序|O(nxk)|O(nxk)|O(nxk)|O(n+k)|Out-place|稳定|', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600487766811&di=5db26ebd1deb5f5bc643437598ebcbbd&imgtype=0&src=http%3A%2F%2Ffiles.ygjj.com%2Fnewsimages%2Fimage%2F20160919%2F20160919091249_8348.jpg', '2', '1', '0', '2020-09-19 09:08:15', '2020-09-19 09:08:15');
INSERT INTO `blog` VALUES ('32', '数据库理论知识点一', '笔记', '转载', '<p>（第一章、第二章）主要讲数据库系统概述理论知识点 例如码、属性、关系、完整性、以及一些运算\n学习过程中挑拣出来的比较重要的知识点，可提供参考希望可以拿来和大家分享交流。</p>\n', '## 数据库\r\n### 第一章\r\n#### 1.1 数据库库系统概述\r\n\r\n* 数据（Data）：描述事务的符号记录称为数据。\r\n* 数据库(DB)：长期存储在计算机内、有组织的、可共享的、大量的数据集合。\r\n    1. 层次模型\r\n    2. 网状模型\r\n    3. 关系模型\r\n* 数据库管理系统(DBMS)：是位于用户与操作系统直间的一层数据管理软件6\r\n* 数据库系统(DBS)：由数据库、数据库管理系统、应用程序和数据库管理员组成（存储、管理、处理和为维护数据的系统）\r\n![avatar](http://118.31.20.205/images/1.1.png)\r\n### 1.2数据模型\r\n![avatar](http://118.31.20.205/images/1.2.1.png)\r\n*   数据模型：对现实事务数据特征的抽象\r\n    *   概念模型：按用户观点对数据和信息建模 实际上是现实世界到机器世界的一个中间层次\r\n        *   表示方法：E-R图\r\n    *   机器世界的数据模型：按计算机系统的观点来组织数据，主要是描述数据的结构约束，而非数据本身的内涵\r\n        *   逻辑模型：按计算机系统的观点对数据建模 主要用于DBMS的实现\r\n        *   物理模型：是数据在计算机中的存储方式，是对数据最底层的抽象 (在计算机中如何存储 主要和硬件相关)\r\n    *  信息世界的基本概念\r\n![avatar](http://118.31.20.205/images/1.2.2.png)	\r\n![avatar](http://118.31.20.205/images/1.2.3.png)		\r\n![avatar](http://118.31.20.205/images/1.2.4.png)		\r\n* 联系：\r\n    * 一对一\r\n    * 一对多\r\n    * 多对多\r\n* 概念模型的表示方法\r\n![avatar](http://118.31.20.205/images/1.2.5.png)		\r\n*  逻辑模型\r\n    *  组成：数据结构、数据操作和数据的完整性约束条件三部分组成\r\n        *  数据结构：描述数据库的组成对象以及对象之间的 联系\r\n        *  数据操作：对数据库中各种对象的实力允许执行的操作的集合，包括操作及有关的操作规则\r\n        *  数据得完整性约束条件：一组完整性规则，给定的数据模型中数据及其联系素偶具有的约值依存规则。\r\n    * 常用逻辑模型：\r\n        * 层次模型（树） 已被淘汰  表示一对多有优势 但是多对多 就比较麻烦了\r\n        * 网状模型（图） 已被淘汰\r\n        * 关系模型（表）\r\n        * 面向对象数据模型  比较新 用的比较少\r\n        * 对象关系数据模型  比较新 用的比较少\r\n        * 半结构化数据模型  比较新 用的比较少\r\n![avatar](http://118.31.20.205/images/1.2.6.png)\r\n![avatar](http://118.31.20.205/images/1.2.7.png)\r\n\r\n* 关系模型\r\n    * 二维表\r\n    * 优点：关系单一\r\n    * 缺点：增加开发系统难度\r\n### 1.3 数据库系统体系结构\r\n\r\n* 型\r\n    *  对某一类数据的结构和属性的说明\r\n*  值\r\n    *  是型的一个具体赋值\r\n* 模式\r\n![avatar](http://118.31.20.205/images/1.3.1.png)\r\n* 外模式\r\n    *  能够看见和使用的局部数据 \r\n    *  模式与外模式的关系：一个模式有多个外模式\r\n* 内模式\r\n    * 记录的存储方式 （例如顺序存储）\r\n    *  索引的组织方式\r\n    *  书记是否压缩、加密等\r\n* 数据库系统的两级映像\r\n![avatar](http://118.31.20.205/images/1.3.2.png)\r\n* BS\r\n* CS \r\n* 分布式结构：地理上分散，逻辑上集中的数据库系统\r\n**总结**\r\n![avatar](http://118.31.20.205/images/总结1.png)\r\n## 第二章关系数据库\r\n### 2.1关系数据结构及其形式化\r\n\r\n* 笛卡尔积\r\n![avatar](http://118.31.20.205/images/2.1.1.png)\r\n* 关系：笛卡尔积的有限子集，所以关系也是一个二维表。\r\n* 超码：若关系中的某一个或多个属性的集合能唯一的表示一个远足，则成该属性或属性组为超码\r\n* 候选码：如果构成超码属性组的任意真子集都不能成为超码，这样的最小码城围候选码\r\n* 主码：唯一的候选码作为主码\r\n eg：![avatar](http://118.31.20.205/images/2.1.2.png)\r\n * 基本关系具有的性质\r\n    *  列是同质的，每一列的分量是同一类型给的数据，来自同一个**<u>域</u>**\r\n    *  不同列可出自通一个域，其中的每一列成为一个属性，不同的 属性 要给予不同的属性名\r\n    *  列的顺序无所谓，列的次序可以任意交换\r\n    *  任意两个元组的<u>**候选码**</u>不能相同\r\n    *  行的顺序无所谓，行的次序可以人以交换\r\n    *  分量必须取<u>**原子值**</u>，每一个份量都必须是不可分的数据项\r\n* 关系和二维表之间的对应\r\n![avatar](http://118.31.20.205/images/2.1.3.png)\r\n* 关系模式：对关系的描述\r\n    * 必须指出这个元祖集合的关系\r\n    * 必须满足一定的完整性约束\r\n![avatar](http://118.31.20.205/images/2.1.4.png)\r\n  关系 模式简记为：R(U)或者R(A1,A2,,.......,An)\r\n    R为关系名，A1,A2,...,An为属性名\r\n![avatar](http://118.31.20.205/images/2.1.5.png)\r\n\r\n| 名称 |区别1  |联系  | 区别2 |\r\n| --- | --- | --- | --- |\r\n| 关系 | 关系是值 | 是关系模式某时刻的状态内容 | 动态的遂渐见变化 的 |\r\n| 关系模式 | 关系模式是型 |      | 静态的 稳定的 |\r\n### 2.2关系操作 、 关系的完整性\r\n\r\n* 关系完整性（针对主码--即主键  ）\r\n    * 数据库的完整性，指数据的正确性和有效性。是指数据是符合现实世界语义、反映当前实际状况的。\r\n    * 完整性约束：\r\n        * 实体完整性：若属性A是基本关系R的主属性，则属性A不能取空值（主键不能为空）\r\n* 参照完整性 （针对外码--即外键）\r\n    * 外码：设F是基本关系R的一个或一组属性，但不是关系R的主码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码（说白了就是外键）\r\n* 用户定义完整性 （没有统一规则 比如（成绩 不一定在 0- 100 比如四六级成绩 雅思 托福） unique、check、not null）\r\n![avatar](http://118.31.20.205/images/2.2.1.png)\r\n### 2.4关系代数\r\n\r\n* 关系代数\r\n    * 一种抽象的而查询语言、用对关系的运算来表达查询\r\n    * 三个要素：\r\n        * 运算对象：关系\r\n        * 运算结果：关系\r\n        * 运  算 符：四类\r\n            * 集合运算符：将关系堪称元组的集合；\r\n                * 运算时从关系的“水平”方向即 行的角度来进行\r\n            * 专门的而运算符 ：\r\n                * 不仅涉及行而且涉及列\r\n            * 比较运算符（> < >= <= = !=）\r\n                * 辅助专门的关系运算符进行操作\r\n            * 逻辑运算符 (与 或 非)\r\n                * 辅助专门的关系运算符进行操作\r\n    *  运算分类：\r\n        *  传统的集合运算：并、差、交、广义笛卡尔积\r\n            *  并、差、交、要求：具有相同数目的属性、 相应的属性取自同一个域\r\n        *  专门的运算关系：选择、投影、连接、除           \r\n* 选择运算：（行运算）\r\n![avatar](http://118.31.20.205/images/2.4.1.png)\r\n* 投影运算：（列运算）\r\n\r\n\r\n\r\n* 连接运算：\r\n    * sie她连接：从两个关系的笛卡尔积中选区属性间满足一定条件的元祖\r\n    * 等值连接：sie她为“=”的链接运算称为等值连接。\r\n    * 自然连接：是一种特殊的等值连接（要求两个关系进行比较的份量必须是同名属性组、在等值连接的结果中去掉重复的属性列）\r\n        自然连接中被舍弃的元祖城围悬浮元组\r\n    * 外连接： 如果把悬浮元组也保存在R和S自然连接的结果管系统，而在其他属性上填空值，那么这种连接就叫外连接\r\n    * 除法运算：   \r\n\r\n**总结**\r\n![avatar](http://118.31.20.205/images/总结2.png)', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600487889197&di=36880a30cd83f8f522e96a11f20cd4cc&imgtype=0&src=http%3A%2F%2Fwww.7xdown.com%2Fup%2F2003%2F202032110576320420.jpg', '1', '1', '0', '2020-09-19 09:10:17', '2020-09-19 09:10:17');
INSERT INTO `blog` VALUES ('33', '数据库理论知识点二', '笔记', '转载', '<p>（第三章、第四章）主要讲SQL语句建表、查询、修改、删除 一些操作性知识点，还有数据库安全性和安全机制\n学习过程中挑拣出来的比较重要的知识点，可提供参考希望可以拿来和大家分享交流。</p>\n', '## 第三章  数据库标准语言SQL\r\n### 3.1SQL概述\r\n\r\n* SQL（Structured Query Language）：简单易学、功能丰富\r\n### 3.2数据定义\r\n* 建表\r\n![avatar](http://118.31.20.205:8888/images/3.2.1.png)\r\n![avatar](http://118.31.20.205:8888/images/3.2.2.png)\r\n![avatar](http://118.31.20.205:8888/images/3.2.3.png)\r\n* 修改表\r\n![avatar](http://118.31.20.205:8888/images/3.2.4.png)\r\n* 索引\r\n    * 在关系数据库种，索引是一种单独的】无力的、虽数据库表中一列或者多列的值进行排序的一种存储结构\r\n    * 他是某个表中一列或者若干列值的集合和响应的指向表中物理标识这些值的数据页的逻辑指针清单\r\n    * 建立索引是加快查询速度的有效手段\r\n* 建立索引\r\n    * DBA或表得到属主根据需要建立\r\n    * 有些DBMMS自动建议一下列上的索引\r\n        * Primary key\r\n        * Unique\r\n* 维护\r\n    * DBMS自动完成索引的维护\r\n* 使用\r\n    * DBMS自动选择是否使用索引以及使用那些索引\r\n* 顾虑\r\n    * 会占用一定空间\r\n    * 对数据增删改操作需要对索引维护\r\n    * 确保提高性能的情况下再建立索引\r\n* 索引的创建\r\n    * 直接方法 建表的时候就创建\r\n    * 间接方法 建好表之后加入\r\n![avatar](http://118.31.20.205:8888/images/3.2.5.png)\r\n unique是唯一取值的索引 bitmap是列下值不唯一时创建索引\r\n*  索引修改\r\n![avatar](http://118.31.20.205:8888/images/3.2.6.png)\r\n*  删除索引\r\n![avatar](http://118.31.20.205:8888/images/3.2.7.png)\r\n### 3.3数据查询\r\n#### 单表查询\r\n![avatar](http://118.31.20.205:8888/images/3.3.1.png)\r\nall查询全部数据\r\ndistinct 去掉重复列\r\n\r\n* 选择表中的若干列\r\n	*  消除取值重复的行 select  disnect 列名 from表名\r\n![avatar](http://118.31.20.205:8888/images/3.3.2.png)\r\n* 查询全部列\r\nselect * from <表名>\r\n\r\n* 查询经过计算的列\r\n to_char(列名，日期格式)（+起个列名）\r\n\r\n*  选择表中的若干元组\r\n    *  消除取值重复的行 select  disnect 列名 from表名\r\n	![avatar](http://118.31.20.205:8888/images/3.3.3.png)\r\n	* 排序查询：\r\n\r\nasc：升序 控制的元组最后显示\r\ndesc：降序 空值的元组最先显示\r\n\r\n* 使用集函数\r\n    * 计数 count（【distinct|all* 】）\r\n    * 计算总和  sum（[distinct|all]<列名>）\r\n    * 计算平均值 avg([distinct|all<列名>])\r\n    * 最大值 max ([distinct|all<列名>])\r\n    * 最小值min ([distinct|all<列名>])\r\n * eg：select avg （grade）from sc where cno=‘001’  \r\n * 对查询结果分组 ： group by\r\n     * 分组结果进行筛选：having短句\r\n\r\n| having | where |\r\n| --- | --- |\r\n| where子句作用于基表或视图，从中选择满足条件的元组 | having短语作用于组，从中选择满足条件的组  |\r\n\r\n#### 连接查询\r\n\r\n* 等值于非等值连接  where 条件为 =或者 非=\r\n* 自身连接：\r\n	![avatar](http://118.31.20.205:8888/images/3.3.4.png)\r\n#### 嵌套查询\r\n一个select-from-where语句称为一个查询块\r\n将一个查询块嵌套到另一个查询块的where子句或having短语的条件中的查询称为嵌套查询\r\n    子查询不能使用orderby语句\r\n#### 集合查询\r\n\r\n* 并\r\n	![avatar](http://118.31.20.205:8888/images/3.3.6.png)\r\n\r\n\r\n\r\n* 交\r\n	![avatar](http://118.31.20.205:8888/images/3.3.7.png)\r\n\r\n* 差\r\n	![avatar](http://118.31.20.205:8888/images/3.3.8.png)\r\n### 3.4数据更新\r\n\r\n* 增\r\n    * 注意如果需要插入日期类型的 则需要用 to_date(\'\',格式)转换成日期类型的\r\n* 删\r\n	![avatar](http://118.31.20.205:8888/images/3.4.1.png)\r\n* 改\r\n* update\r\n	![avatar](http://118.31.20.205:8888/images/3.4.2.png)\r\n### 3.5视图\r\n\r\n* 定义：视图是从一个或者几个基本表（或视图）导出的表，他与基本表不同，他是一个虚表\r\n    * 数据库中只存放使徒的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中\r\n    * 基本标中数据发生变化，从视图中查询出得到数据也随之改变\r\n* 创建视图：\r\n	![avatar](http://118.31.20.205:8888/images/3.5.1.png)\r\n\r\nwith check option：加上的话更新视图数据必须满足插入数据的条件\r\n\r\n* 删除视图\r\n	![avatar](http://118.31.20.205:8888/images/3.5.2.png)\r\n\r\n* 常见视图\r\n	![avatar](http://118.31.20.205:8888/images/3.5.3.png)\r\n\r\n* 行列子集视图：若一个表是从党额基本标导出，只是去掉了基本标的某些行和列，但保留了主码，则这类视图为行列子集视图\r\n\r\n**总结**\r\n	![avatar](http://118.31.20.205:8888/images/zj3.png)\r\n## 第四章 数据库安全性概述\r\n### 4.1数据库安全性概述\r\n为了适应和满足数据共享的环境和要求，DMBMS要保证整个系统的正常运转，防止数据泄露，恶意修改，不一致产生，产生问题后的及时回复，需要一整套而有效的保护措施\r\n*    DBMS对数据安全的保护功能：\r\n    *    安全性控制：   方式数据泄露恶意修改\r\n    *    完整性控制：   防止数据的不一致性\r\n    *    并发性控制：   防止数据的不一致性\r\n    *    数据库恢复：   产生问题后的及时恢复\r\n\r\n### 安全控制机制 \r\n\r\n* 数据库的安全性：保护数据库以防止非法使用所造成的数据泄露、更改或破坏\r\n* 安全性控制的主要问题：尽可能杜绝所有可能的数据库非法访问\r\n	![avatar](http://118.31.20.205:8888/images/4.1.1.png)\r\n* 数据库安全性控制手段：\r\n    * 用户标识和鉴定\r\n        * 由系统提供一定的方式让用户表示自己的名字或身份，系统内部记录着所有合法用户的标识\r\n        * 没此用户要求进入系统时，由系统进行核实，通过鉴定后才提供机器的使用权\r\n        * 缺点：\r\n            * 简单易行但是用户口令比较简单容易被窃取\r\n    * 用户存取权限控制\r\n		![avatar](http://118.31.20.205:8888/images/4.1.2.png)\r\n		* 比较消耗时间\r\n    * 定义视图\r\n        * 为不同的用户定义不同的视图，可以限制各个用户的访问范围\r\n        * 视图是逻辑存在的，其修改操作会受到限制\r\n    * 数据加密\r\n        * 根据一定算法将原始数据加密成为不可直接识别的格式，数据以密文的形式存储和运输\r\n            * 替换方法：使用密钥将明文中的每一个字符换为密文中的字符\r\n            * 转换方法：将明文中的字符按不同的顺序重新排列\r\n    * 数据审计\r\n        * 监视措施：把访问数据库的操作记录下来，并把日志返回给管理员\r\n* SQL Server数据安全机制\r\n    * 服务器级别的安全性\r\n    * 数据库及其对象的安全性\r\n\r\n### 设置验证身份模式\r\n\r\n* SQL Server的身份验证模式\r\n    * Windows身份验证模式\r\n    * 混合身份验证模式\r\n* 身份验证模式的设置 \r\n\r\n### 服务器级安全管理\r\n\r\n* SQL Server登陆账号的相关操作\r\n    * 登陆账号\r\n    * 数据库用户账号\r\n	![avatar](http://118.31.20.205:8888/images/4.1.3.png)\r\n* SQL Server身份验证模式\r\n* SQLServer度武器角色\r\n\r\n### 设置登录账号和角色\r\n\r\n* SQL Server中账号的类型\r\n* 创建登陆账号\r\n* 修改登陆账号\r\n* 删除登陆账号\r\n* 服务器角色\r\n\r\n### 数据库级安全管理\r\n\r\n* 数据库用户账号\r\n    * 用户账号要在特定的数据库内创建，并关联一个登陆账号\r\n    * ![avatar](http://118.31.20.205:8888/images/4.1.4.png)\r\n    * 可以使用‘对象资源管理器’创建\r\n    * 设置映射，用户账号可以使用管理那些数据库\r\n\r\n\r\n### 设置用户账号\r\n\r\n*    用户账号和登陆账号的区别\r\n*    创建数据库用户账号\r\n*    查看和修改数据库用户账号\r\n*    删除数据库用户账号\r\n*    数据库用户角色', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600487889197&di=36880a30cd83f8f522e96a11f20cd4cc&imgtype=0&src=http%3A%2F%2Fwww.7xdown.com%2Fup%2F2003%2F202032110576320420.jpg', '1', '1', '0', '2020-09-19 09:11:21', '2020-09-19 09:11:21');
INSERT INTO `blog` VALUES ('34', '数据库理论知识点三', '笔记', '转载', '<p>（第五章、第六章、第七章）主要讲数据库的完整性、以及规范化问题\n学习过程中挑拣出来的比较重要的知识点，可提供参考希望可以拿来和大家分享交流。</p>\n', ' ## 第五章数据库完整性\r\n  数据库的完整性是指数据的正确行和有效性。是指数据是符合显示世界语义、反映当前实际状况的 \r\n  通过对关系（二维表） 中取值的约束，可以保证数据库的完整性，保证数据的正确性\r\n ### 实体完整性（主键）\r\n\r\n*  列级约束\r\n    *  创建表时写在列后边\r\n*  表级约束\r\n    *  创建好表后在写PRIMARY KRY( ，)\r\n* 实体完整性的检查和违约处理\r\n\r\n| 数据操作 | 是否违反实体完整性  | 违约处理 |\r\n| --- | --- | --- |\r\n| 删除 |否  |  |\r\n|插入  | 有可能 |  拒绝|\r\n| 修改 |  有可能| 拒绝 |\r\n| 查询 |否  |  |\r\n\r\n  ### 参照完整性（外键）\r\n\r\n*   参照完整性的规则： 若属性F是基本关系R的外码，他与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值 要么取空要么等于S中某个元组的主码值\r\n![avatar](http://118.31.20.205:8888/images/5.1.1.png)\r\n* 参照完整性的检查和违约处理\r\n\r\n| 主键关系学生表 | 外键关系选课表  | 违约处理 |\r\n| --- | --- | --- |\r\n| 删除元组 |可能破坏参照完整性  |拒绝/级联删除/设置空值  |\r\n|有可能破坏参照完整性  | 插入元组 |  拒绝|\r\n| 修改主码值 |  有可能破坏参照完整性| 拒绝/级联更新/设置空值  |\r\n| 有可能破坏参照完整性 |修改外码值|拒绝  |\r\n![avatar](http://118.31.20.205:8888/images/5.1.2.png)\r\n\r\n  ### 用户定义的完整性\r\n\r\n*   用户定义完整性规则：\r\n    *   用户定义的完整性是针对某一具体关系数据库的约束条件反应某一具体应用所设计的数据必须满足语义要求\r\n    *   用户定义的完整性没有统一的语义要求来创建\r\n    *   eg：成绩的取值范围 由用户定义\r\n* 实现：\r\n    * 在 CREAT TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制\r\n    * 同属性值限制相比，元组级的限制可以设置不同属性之间取值的相互约束条件\r\n* 违规处理\r\n    * 插入元祖和修改属性的值时，RDBMS检查属性上的约束条件是否被满足\r\n    * 如果不满足则操作被拒绝执行\r\n    * | 数据操作 | 是否违反实体完整性  | 违约处理 |\r\n	\r\n| 数据操作 | 是否违反实体完整性  | 违约处理 |\r\n| --- | --- | --- |\r\n| 删除 |否  |  |\r\n|插入  | 有可能 |  拒绝|\r\n| 修改 |  有可能| 拒绝 |\r\n| 查询 |否  |  |\r\n\r\n  ### 完整性约束命名子句\r\n  给完整性约束起名字：CONSTARAINT +约束名+约束条件\r\n  ![avatar](http://118.31.20.205:8888/images/5.1.3.png)\r\n  ![avatar](http://118.31.20.205:8888/images/5.1.4.png)\r\n   ## 第六章 -->无\r\n  \r\n  ## 第七章\r\n  ### 问题的提出（规范化）\r\n\r\n*   数据冗余\r\n*   更新异常\r\n*   插入异常\r\n*   删除异常\r\n#### 规范化\r\n\r\n* 规范化概念：是关系模式优化的理论基础\r\n    \r\n* 基本思想：通过关系模式垂直分解来消除数据项之间的饿不合适的数据依赖，防止插入异常、查出一场和数据荣誉等异常的发生\r\n* 函数依赖  * 忽* 略 * 了\r\n* 范式： 关系数据库中的关系必须满足一定的要求，满足不同程度要求就称为不同的范式，用R∈xNF描述\r\n    * x标识范式的级别\r\n	  ![avatar](http://118.31.20.205:8888/images/7.1.png)\r\n	   * 一个低一级的范式的关系模式，通过模式垂直分解的方法，转换为若干个高一级范式的关系模式的集合，这种过程称为规范化\r\n        * 遵照原则：一事一地原则\r\n        * 解决方法：模式垂直分解\r\n        * 分解时注意：\r\n            * 保持函数依赖的分解：指在模式分解的过程中函数依赖不能丢失特性，即模式分解不能破坏原来的语义\r\n            * 保持数据不丢失的分解：分解后额杜关系通过自然连接可以恢复成原来的关系，既不多出信息，又不丢失信息\r\n   * 1NF ：如果一个关系模式R的所有属性值（分量）均为原子项，则称R∈1NF\r\n       * 第一范式时对关系模式最起码的要求。不满足第一范式的数据库模式不能称为关系数据库\r\n       * 满足第一范式的关系模式，并不一定是一个好的关系模式\r\n   * 2NF：若关系 R∈1NF，且每一个非主属性均完全函数依赖于R的关系码，则R∈2NF\r\n   * 3NF：舍关系模式<U,F>∈1NF，若R中不存在所有的非主属性对码的传递函数依赖，则称R<U,F>∈3NF\r\n  ### 数据依赖公理系统\r\n\r\n*   Armstrong公理系统\r\n    *   函数依赖的逻辑蕴含\r\n    *   Armstrong公理系统中推理规则；\r\n    *   计算机属性集的闭包\r\n    *   计算最小函数依赖集\r\n    *   求解关系模式的候选码的方法\r\n### 模式分解\r\n\r\n*   对于一个模式的分解是多种多样的，但分解后产生的模式应与原模式等价\r\n*   模式分解要满足：\r\n    *   具有无损连接性\r\n        *   指分解后的关系通过自然连接具有和原关系等价的特性，即通过自然连接得到的关系与原来的关系相比，既不多出信息、又不丢失信息\r\n    *   保持函数依赖\r\n    *   判断是否为模式分解\r\n        *   生成空表格\r\n![avatar](http://118.31.20.205:8888/images/7.2.png)\r\n        *   按照算法填写表格\r\n![avatar](http://118.31.20.205:8888/images/7.3.png)\r\n![avatar](http://118.31.20.205:8888/images/7.4.png)\r\n        *   应用每一个函数依赖关系修正表格\r\n ![avatar](http://118.31.20.205:8888/images/7.5.png)\r\n![avatar](http://118.31.20.205:8888/images/7.6.png)\r\n        *   以找算法要求，得出结论\r\n![avatar](http://118.31.20.205:8888/images/7.7.png)\r\n        *  eg:看有没有AB两行相同而他的C行之不一样\r\n ![avatar](http://118.31.20.205:8888/images/7.8.png)\r\n\r\n** 小结**\r\n ![avatar](http://118.31.20.205:8888/images/zj7.png)', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600487889197&di=36880a30cd83f8f522e96a11f20cd4cc&imgtype=0&src=http%3A%2F%2Fwww.7xdown.com%2Fup%2F2003%2F202032110576320420.jpg', '1', '1', '0', '2020-09-19 09:13:44', '2020-09-19 09:13:44');
INSERT INTO `blog` VALUES ('35', '数据库理论知识点四', '笔记', '转载', '<p>（第八章章、第九章）主要讲数据库设计概述、需求分析、数据流图还有数据库实施、维护并发与维护、锁。\n学习过程中挑拣出来的比较重要的知识点，可提供参考希望可以拿来和大家分享交流。</p>\n', '## 第八章\r\n### 数据库设计概述\r\n\r\n* 什么是数据库设计：数据库设计是指对于一个给定的应用环境，构造（设计）优化**数据库逻辑模式和物理结构**，并据此建立数据库及其应用系统，使之能够有效的存储数据，满足各种用户的应用需求，包括信息管理要求和**数据操作**要求\r\n* 数据库设计的目的：数据共享，为用户和各种应用系统提供一个信息基础设施和高效率的运行环境\r\n* 数据库设计的\r\n    * 特点：三分技术，七分管理，十二分基础数据\r\n* 手工共与经验相结合的方法\r\n    * 设计质量与设计人员的经验和水平有直接关系，它使数据库设计成为一种以上述而不是工程技术\r\n    * 数据库运行一段时间后常常有不同程度地发现各种问题，增加了维护代价\r\n* 典型的规范设计方法\r\n    * 新奥尔良方法：将数据库设计分为若干个阶段\r\n    * 基于E-R模型的数据库设计方法：概念设计阶段**广泛采用**\r\n    * 基于3NF的设计方法：逻辑阶段可采用的有效方法\r\n    * ODL的设计方法：面向对象的数据库设计方法\r\n#### 数据库设计的基本步骤\r\n\r\n* 需求分析阶段\r\n    * 准确了解与分析用户需求（包括数据与处理）\r\n    * 设计过程中的基础，也是最困难、最耗时间的一步\r\n* 概念结构设计阶段\r\n    * 是整个数据库设计的关键\r\n    * 通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型\r\n* 逻辑结构设计阶段\r\n    * 将概念结构转换为某个DBMS所支持的数据模型，如关系模型，形成数据库逻辑模式；根据用户处理的要求、安全性的考虑，在基本的表基础上在建立必要的视图，形成数据库的外模式\r\n    * 对其进行优化\r\n* 数据库物理设计阶段\r\n    * 为逻辑数据模型选取一个最适合应用环境的物理结构，根据DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式\r\n* 数据库实施阶段\r\n    * 运用DBMS提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果:\r\n        * 建立数据库\r\n        * 编制与调试应用程序\r\n        * 组织数据入库\r\n        * 并进行试运行\r\n* 数据库运行和维护阶段\r\n    * 数据库应用系统经过试运行后即可投入正式运行。\r\n    * 在数据库系统运行过程中必须不断地对其进行评价、调整与修改。\r\n### 需求分析\r\n\r\n* 调查过程：本质是对数据流程的调查\r\n* 传统的系统调查方法有：\r\n    * 资料手机\r\n    * 访谈\r\n    * 实地观察\r\n    * 问卷调查\r\n* 事件与系统需求\r\n* 时间类型：\r\n    * 外部事件：在系统之外发生，通常由外部的人或组织激发的事件，这些人或组织是数据的提供者和接收者\r\n        * 寻找外部事件：\r\n            * 确定外部实体，分析\r\n            * 外部实体需要一个事务处理\r\n            * 外部实体需要系统提供某些信息\r\n            * 某些数据改变了，系统需要更新它们\r\n            * 管理过程需要某些信息\r\n    * 时间事件：时间自动触发，即当系统事件达到某一刻是发生的事件，这些事件通常要求系统能定时地完成某些输出或处理\r\n        * 注意：命名时必须包含所要完成的**处理和规定期限**\r\n    * 状态事件：系统内部的变化触发系统对某个处理的需要，这种情况的发生称为状态事件\r\n        * 状态事件一般是外部事件的结果，它的发生是不定时的\r\n* 识别时间的规则\r\n    * 区分时间与具体响应过程\r\n    * 跟踪关键业务的整个生命周期来发现事件\r\n    * 暂时忽略技术性依赖事件和系统控制事件\r\n* 事务类型\r\n* 事务之间的关系\r\n* 事务之间关系基数\r\n* 事务属性：能唯一区别事务\r\n* 需求定义\r\n    * 需求分析是分析人员与用户反复沟通和谈判的过程\r\n    * 需求定义就是在各方就系统需求达成一致意见后，整理并把需求表示出来，详细定义和描述每项需求，确认约束条件及限制，编写相关文档说明书\r\n    * 需求定义：\r\n        * 自然语言\r\n        * 模型定义\r\n * 定义和表示需求常用的建模工具：\r\n     * 流程建模\r\n         * 业务流程（业务流程图/UML活动图）\r\n         * 数据处理流程（数据流程图、数据字典）\r\n     * 用例建模\r\n         * 信息系统功能模型（UML用例图）\r\n     * 领域对象建模\r\n         * 领域对象模型（UML类图、UML状态图）  \r\n#### 数据流图\r\n\r\n* 数据流程图（DFD）\r\n![avatar](http://118.31.20.205:8888/images/8.1.png)\r\n*  基本符号\r\n    *  Gane-Sarson甘恩-萨森画法\r\n![avatar](http://118.31.20.205:8888/images/8.2.png)\r\n    *  外部实体：指系统以外又与系统有联系的人或者事务。它表达了该系统数据的外部来源和去处\r\n        *  外部实体是数据得来源\r\n        *  外部实体是数据的去处\r\n    *  数据处理：对数据的逻辑处理功能\r\n        *  功能、处理过程、数据加工\r\n ![avatar](http://118.31.20.205:8888/images/8.3.png)\r\n    * 数据流：指处理过程的输入或输出（箭头表示数据流向）\r\n![avatar](http://118.31.20.205:8888/images/8.4.png)\r\n    *  数据存储：表示某种数据保存后的逻辑同城，不是指保存数据  的物理地点或物理介质\r\n        *  数据存储的数据流：将处理后的数据**写入或修改**到数据存储中\r\n        *  数据存储的数据流：从数据存储中**查询**获得数据，不改变原来的数据     \r\n* 数据流程图的绘制方法\r\n    * 理解系统的业务流程-->称为业务专家\r\n    * 寻找系统中的事件-->找到系统单个功能（数据流图片段，表达单个数据处理功能）\r\n    * 归纳并重构系统的处理流程图-->构造系统完整功能(完整数据流图)\r\n* 绘制数据流图的注意事项\r\n    * 合理的层次划分\r\n        * 展开的层次与管理层次一直，也可以划分的更仔细\r\n        * 同一张图上的所有处理过程应尽可能处于同一个抽象层次上\r\n        * 一个处理框经过展开，一半以分解为4~10处理框为宜\r\n            * 如果一次分解后仅有**两个处理框**，为减少数据流图的层次，可以将他们直接并入上一层中。\r\n            * 一个处理框分解后还是只有**一个处理**框，而视为无效的分解\r\n        *  最下层的处理过程用几句话，或者几张判定表，或一张见到那的HIPO图能表达清楚\r\n    * 正确性的检查\r\n        * 数据守恒（输入输出数据是否匹配）\r\n        * 数据存储：必定有流入的数据和流出的数据\r\n        * 父图中某一处理框的输入、输出数据必须出现在相应子图中\r\n        * 任何一个数据流至少有一端是处理框\r\n    * 可读性\r\n        * 利用数据村属简化处理间的联系\r\n        * 每层的处理框需要均匀分解，齐头并进\r\n        * 适当命名\r\n    * 确定系统边界\r\n        * 管理模型-->信息处理模型-->计算机程序\r\n        * 信息处理模型需要从业务处理中抽象出数据处理过程\r\n        * 因此要关注信息系统解决的问题，重点是系统中的数据处理和流动并考虑人机分工\r\n* 数据流图优点：\r\n    * 图形元素少，易学易读，容易与用户沟通\r\n    * 有层次性，允许系统分析员由上至下逐步分析系统，不会受困于天多复杂的细节\r\n* 数据流图缺点：\r\n    * 不能描述系统的控制流\r\n    * 潜在的非语法错误不易发现，复核困难，需要有一定的额分析设计经验\r\n* 数据字典：\r\n    * 为什么要建立数据字典：\r\n        * 数据流图表达不够准确、具体，只有将每个成分都给给出定义之后，才能完整、准确地描述一个系统\r\n        * 建立数据字典来对数据流图的各个元素作出详细的说明\r\n    * 数据字典的作用：\r\n        * 有助于改进系统分析员和用户之间的通信，从而消除他们直间的许多误解\r\n        * 有助于改进在不通的开发人员或不同的开发小组之间的通信，加快系统开发的进度\r\n        * 是开发数据库的第一步，而且是很有价值的一步\r\n### 概念结构设计\r\n\r\n* 概念结构设计：将需求分析得到的用户的需求抽象为信息结构即概念模型的过程\r\n    * 是各种数据模型的共同基础、它比数据模型更独立于及其、更抽象，从而更加稳定\r\n    * 是整个数据库设计的关键\r\n* 设计步骤\r\n    * 设计局部E-R图\r\n    * 综合成初步E-R图\r\n![avatar](http://118.31.20.205:8888/images/8.5.png)\r\n    * 优化成基本E-R图\r\n* 设计常用策略\r\n    * 自底向上地设计概念结构\r\n        * 抽象数据并设计局部视图\r\n        * 集成局部视图，得到全局概念结构\r\n\r\n### 逻辑结构设计\r\n![avatar](http://118.31.20.205:8888/images/8.6.png)\r\n\r\n* E-R图向关系模型的转换（模型转化为二维表）\r\n    * 如何将实体和实体间的关系转换为关系模式\r\n        * 关系的属性：实体型的属性\r\n        * 关系的码：实体型的码\r\n    * 一个m:n联系转换为一个关系模式\r\n        *     关系得属性：与该联系相连的各实体的主码以及联系本身的属性\r\n        *     关系的主码：各实体主码的组和\r\n    * 一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并  \r\n        * 转换为一个独立的关系模式\r\n            * 关系的属性：与该联系相连的各实体的主码以及联系本身的属性\r\n            * 关系的主码：  n端实体的主码\r\n        * 与n端对应的关系模式合并\r\n            * 合并后关系的属性：在n端关系中假如1端关系的主码和联系本身的属性\r\n            * 合并后关系的主码：不变\r\n    * 一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 \r\n        * 转换为一个独立的关系模式\r\n            * 关系的属性：与该联系相连的各实体的主码以及联系本身的属性\r\n            * 关系的候选码：每个实体的主码均是该关系的候选码\r\n        * 与 某一段对应的关系模式合并\r\n            * 合并后关系的属性：假如对应关系的主码和联系本身的属性\r\n            * 合并后关系得主码：不变\r\n    * 三个或三个以上实体间的一个多元联系转换为一个关系模式\r\n        * 关系的属性：与该多元联系相连的各个实体的主码以及联系本身的属性\r\n        * 关系的主码：各实体主码的组和\r\n    * 具有相同码的关系模式可合并\r\n        * 目的：减少系统中关系个数\r\n        * 合并方法：将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性，并适当调整属性的次序  \r\n    * 如何确定这些关系模式的属性和码\r\n* 逻辑模型设计的结果不唯一\r\n    * 得到初步数据模型后,还应当适当的去修改、调整数据模型的结构，以进一步提高数据库应用系统的行能，这就是数据模型的优化\r\n    * 关系数据模型的优化通常以规范化理论为指导\r\n* 优化方法：\r\n    * 确定依赖\r\n    * 消除冗余\r\n    * 确定所属范式\r\n    * 分析是否适合数据库应用环境\r\n    * 对模式进行必要分解，提高数据操作效率和存储空间利用率\r\n        * 水平分解：把（基本）关系的元组分解为若干子集合，定义每个子集合为一个子关系，以提高系统的效率\r\n        * 垂直分解：把关系模式R的属性分解为若干子集合，形成若干个子关系模式\r\n            * 前提：分解后数据库效率可以得到提高\r\n\r\n### 物理结构设计\r\n\r\n* 什么是数据库的物理设计：\r\n    * 数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于给定的计算机系统\r\n    * 为一个给定的逻辑数据模型选区一个最适合应用环境的物理结构的过程，就是数据库的物理设计\r\n* 设计步骤\r\n    * 确定数据库的理论结构，在关系数据库中主要指存取方法和存储结构\r\n    * 对物理结构进行评价，评价的重点是时间效率和空间效率\r\n* DBMS常用存取方法：\r\n    * 索引法：\r\n        * B+树索引\r\n            * 需要确定：对哪些属性列建立索引？对哪些属性列建立组合索引？对哪些索引要设计为唯一索引\r\n            * 索引过多的话 维护、查找索引会带来很大消耗\r\n        * hash索引\r\n    * 聚簇方法 \r\n        * 概念：为了提高某个属性或属性组的查询速度，把这个或者这些属性上具有相同值得元组集中存放在连续得物理块中称为聚簇\r\n![avatar](http://118.31.20.205:8888/images/8.7.png)\r\n        * 用途：\r\n            * 大大提高聚簇属性查询的效率\r\n            * 节省存储空间\r\n        * 局限性：\r\n            * 只能提高某些特定应用的行能 \r\n            * 建立与维护时的开销相当大\r\n * 确定数据库的物理结构:存储结构和存放位置\r\n     * 确定数据的存放位置\r\n         * 硬件环境\r\n         * 应用需求： 存取事件、存储空间利用率、维护代价。\r\n         * 基本原则：分开存放\r\n             * 易变部分与稳定部分\r\n             * 存取频率较高部分与存取效率较低部分\r\n\r\n### 数据库的实施与维护\r\n\r\n* 数据库的实施：（用SQL语句建表）\r\n    * 用DDL定义数据库结构\r\n    * 组织数据入库\r\n    * 编制与调试应用程序\r\n    * 数据库试运行\r\n* 运行维护\r\n    * 需要不断进行优化 长期进行\r\n**小结**\r\n![avatar](http://118.31.20.205:8888/images/zj8.png)\r\n\r\n## 第九章数据库的并发与恢复\r\n### 并发控制\r\n![avatar](http://118.31.20.205:8888/images/9.1.png)\r\n\r\n* 事务是数据库中执行的一个工作单位，它是由用户定义的一组操作序列\r\n* 一个事务可以是一组SQL语句、一条SQL语句或整个程序，一个应用程序可以包括多个事务\r\n* 定义事务语句：\r\n    * BEGIN TRANSACTION 事务的开始\r\n    * COMMIT 事务的提交\r\n    * ROLLBACK 事务的回滚\r\n* 事务的特性：\r\n    * 原子性：不做或者全做，不允许只完成部分\r\n    * 一致性：指数据库中的数据满足完整性约束、\r\n    * 隔离性：如果多个事务并发执行，应有独立空间互不打扰\r\n    * 持久性：事务一旦提交，数据应该具有持久性，即使数据库受到破坏，DBMS也应该能够恢复\r\n* 并发后果：\r\n    * 丢失更新：\r\n  ![avatar](http://118.31.20.205:8888/images/9.2.png)\r\n    * 污读\r\n  ![avatar](http://118.31.20.205:8888/images/9.3.png)\r\n    * 不可重读\r\n  ![avatar](http://118.31.20.205:8888/images/9.4.png)\r\n* 实现并发控制的方法：\r\n    * 封锁技术\r\n        * 概念：就是当一个事务在对某个数据对象进行操作之前必须获得相应的锁，以保证数据操作的正确性和唯一性\r\n        * 锁的类型\r\n            * 排它锁（封锁）：简称为X封锁，它采用的原理时禁止并发操作\r\n            * 共享锁（读锁）：简称为S锁，它允许用户读取，但是不允许修改\r\n        * 一级封锁协议：t1先上X锁 此时t2只有等t1完成事务时才能上锁\r\n        * 二级封锁协议：在一级封锁基础上的等t1事务回滚完成t2上Ssuo读取事务此时就可以避免污读\r\n        * 三级封锁协议：在一级封锁协议的基础上，另外加上事务t1在读取数据R之前必须先对其加S锁，读完之后不立马释放，而指导事务T结束才释放\r\n        * 封锁粒度（封锁单位）：可以是：字段、记录、表、数据库\r\n  ![avatar](http://118.31.20.205:8888/images/9.5.png)\r\n        *  活锁：当某个事物请求对某一数据进行排它性封锁时，由于其他事物对该数据的操作而使这个十五处于永久等待状态，这种中泰称为活锁\r\n        *  死锁：在同时处于等待状态的两个或者多个事务中，其中的每一个在它能够进行之前，都等待着某个数据，而这个数据已被他们中的某个事物所封锁这种状态称为死锁 \r\n        *  死锁预防：\r\n            *  一次加锁法：一次性对所有资源加锁，如果有一个资源无法加锁，则等待\r\n            *  顺序加锁法：规定的序号，按序号加锁         \r\n    * 时标技术    \r\n  ![avatar](http://118.31.20.205:8888/images/9.6.png)\r\n\r\n\r\n### 数据库恢复\r\n\r\n* 含义：将数据库从错误状态转换为正确状态\r\n* 登记日志文件\r\n    * 日志的内容：\r\n    * 更新数据库的事务标识（标明哪个是事务）\r\n    * 操作的类型（插入、删除或者修改）\r\n    * 操作对象\r\n    * 更新前数据的旧值（插入没有旧值）\r\n    * 更新后数据的新值（删除没有新值）\r\n    * 事务处理中各个关键时刻（事务开始、结束及其真正回写时间）\r\n* 数据转储：定期将数据库复制到多个存储设备（磁带、磁盘）上\r\n    * 存储方式：海量转储和增量转储\r\n    * 存储运行方式：静态转储和动态转储\r\n    * 存储位置：同城和异地\r\n* 故障及恢复\r\n    * 事务故障：程序中的异常结束所造成的故障\r\n        * 恢复：反向扫描日志文件，找出该事务更新操作\r\n        * 对该事务的更新操作执行反操作\r\n    * 系统故障：在运行过程中，由于某种原因，造成系统听自己运转，致使所有正在运行的事务都以非正常方式终止，要求系统重新启动\r\n        * 恢复：查账尚未提交的事务，将其事务标识记入撤销队列。同时查找已提交的事务，将其事务标识记入重做队列\r\n        * 对撤销队列中的各个事务进行撤销处理\r\n        * 对重做队列中的各个事务进行重做处理\r\n    * 介质故障：存储器介质受到破坏，使存储在外存中的数据部分丢失或全部丢失\r\n        * 恢复：装入最新的转储\r\n        * 装入最新的日志文件副本\r\n        * 找出发生故障前已提交的事务，将其记入重做队列。再对重做队列中的各个事务进行重做处理\r\n  ![avatar](http://118.31.20.205:8888/images/9.7.png)', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1600487889197&di=36880a30cd83f8f522e96a11f20cd4cc&imgtype=0&src=http%3A%2F%2Fwww.7xdown.com%2Fup%2F2003%2F202032110576320420.jpg', '8', '1', '0', '2020-09-19 09:14:26', '2020-09-19 09:14:26');
INSERT INTO `blog` VALUES ('36', '关于SpringCloud', 'SpringCloud', '转载', '<p>SpringCloud：基于SpringBoot提供了一套微服务解决方案, 包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。</p>\n', '## 1、 从面试题开始\r\n\r\n### 1、微服务的由来\r\n\r\n微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。 \r\n\r\n### 2、为什么需要微服务\r\n\r\n在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。 \r\n\r\n### 3、微服务与单体架构区别\r\n\r\n（1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。\r\n\r\n​     微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。\r\n\r\n（2）单体架构所有的模块都共用一个数据库，存储方式比较单一。\r\n\r\n​     微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。\r\n\r\n（3）单体架构所有的模块开发所使用的技术一样。\r\n\r\n​     微服务每个模块都可以使用不同的开发技术，开发模式更灵活。 \r\n\r\n\r\n\r\n### 4、微服务本质\r\n\r\n（1）微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。\r\n（2）微服务的目的是有效的拆分应用，实现敏捷开发和部署 。\r\n（3）微服务提倡的理念团队间应该是 inter-operate, not integrate 。inter-operate是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合能变弱，跨系统的沟通成本也就能降低。\r\n\r\n\r\n### 5、什么样的项目适合微服务\r\n\r\n微服务可以按照业务功能本身的独立性来划分，如果系统提供的业务是非常底层的，如：操作系统内核、存储系统、网络系统、数据库系统等等，这类系统都偏底层，功能和功能之间有着紧密的配合关系，如果强制拆分为较小的服务单元，会让集成工作量急剧上升，并且这种人为的切割无法带来业务上的真正的隔离，所以无法做到独立部署和运行，也就不适合做成微服务了。\r\n\r\n### 6、微服务开发框架\r\n\r\n目前微服务的开发框架，最常用的有以下四个：\r\n\r\nSpring Cloud：http://projects.spring.io/spring-cloud（现在非常流行的微服务架构）\r\n\r\nDubbo：http://dubbo.io\r\n\r\nDropwizard：http://www.dropwizard.io （关注单个微服务的开发）\r\n\r\nConsul、etcd&etc.（微服务的模块）\r\n\r\n\r\n\r\n### 7、什么是Spring Cloud\r\n\r\nSpring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、 熔断器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包\r\n\r\n### 8、Spring Cloud和Spring Boot是什么关系\r\n\r\nSpring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，必须基于Spring Boot开发。可以单独使用Spring Boot开发项目，但是Spring Cloud离不开 Spring Boot。\r\n\r\n### 9、springCloud和Dubbo有哪些区别\r\n\r\n* Dubbo基于tcp的rRPC、 cloud是http协议的RESTful API\r\n\r\n### 10、Springboot和SpringClout，请你谈谈对他们的理解\r\n\r\n* Springboot专注于快速方便的开发单个个体微服务\r\n* SpringCloud是关注全局的微信服务协调整理治理框架，他将Springboot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配偶制管理、服务发现、断路器、路由、微代理、事件总线、全局所、决策竞选、分布式会话等等集成服务\r\n* Springboot可以离开SpringCloud独立使用开发项目，但SpringCloud离不开Springboot，属于依赖关系\r\n* Springboot专注于快速、方便的开发但各微服务个体，SpringCloud关注全局的服务治理框架\r\n\r\n### 11、什么是服务熔断？什么是服务降级\r\n\r\n### 12、微服务的优缺点是什么？说一下你在项目开发中碰到的坑\r\n\r\n### 13、你所知道的威武福技术栈有哪些？请举例一二\r\n\r\n### 14、eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别\r\n\r\n## 2、微服务概述\r\n\r\n### 1、微服务与微服务架构\r\n\r\n#### 1.1微服务\r\n\r\n* idea工具里面用maven开发的一个个独立的小module，具体是使用\r\n* springboot开发的一个小模块，专业的事情交给专业的人做，一个模块\r\n* 就做这一件事、强调的是一个个的个体，每个完成特定的任务\r\n\r\n* 强调的是服务的大小，**它关注的是某一个点**, 是具体解决某一个问题/ 提供落地对应服务的一个服务应用,狭意的看,可以看作Eclipse里面的一个个微服务工程/或者Module\r\n\r\n#### 1.2微服务架构\r\n\r\n* 微服务架构是一种架构模式， 它提倡将单一应用程序划分成- 组小的服务,服务之间互相协调、互相配合,为用户提供最终价值。\r\n* 每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作(通常是基于HTTP协议的RESTful API)。\r\n* 每个服务都围绕着具体业务进行构建,并且能够被独立的部署到生产环境、类生产环境等。另外,应当尽量避免统-的、集中式的服务管理机制，对具体的一个服务而言,应根据业务.上下文,选择合适的语言、干具对其进行构建。\r\n\r\n### 2微服务优缺点\r\n\r\n* 优点\r\n  * 每个服务足够内聚，足够小，代码容易理解这样能聚焦一个制定业务功能或需求\r\n  * 开发简单、开发效率提高，一个服务可能就是专一的干一件事\r\n  * 微服务能被小团队单独开发，这个 小团队是2-5个开发成员组成\r\n  * 微服务是松耦合的，是功能意义的服务，无论是在开发阶段或不熟阶段都是独立的\r\n  * 能使用不同的语言开发\r\n  * 易于集成第三方，微服务允许且灵活的方式集成自动部署，通过持续集成工具如：Jenkins，Hudson，bamboo。\r\n  * 易于修护\r\n  * **微服务只是业务逻辑的代码，不会和HTML，CSS或其他界面组件混合**\r\n  * 每个微服务都可以有自己的数据库，连接公共库、也可以有统一数据库\r\n* 缺点\r\n  * 开发人员要处理分布式系统的复杂性\r\n  * 多为服务运维度，随着服务增加，运维的压力也在增大\r\n  * 系统部署以来\r\n  * 服务器间通信成本\r\n  * 数据一致性\r\n  * 系统集成测试\r\n  * 性能监控\r\n\r\n### 3、微服务 技术栈有哪些\r\n\r\n* 微服务技术栈：多种技术的集合体\r\n* 我们在讨论一个分布式的微服务架构的话，他需要有哪些维度？\r\n  * 服务治理、服务注册、服务调运、服务负载均衡、服务监控、服务开发，配置与管理......+对应微服务的落地技术\r\n\r\n### 4、为什么选择springCloud作为微服务架构\r\n\r\n* 选型依据\r\n  * 整体解决方案和框架成熟度\r\n  * 社区热度\r\n  * 可维护性\r\n  * 学习曲线\r\n* 当前各大IT公司用的微服务加购有哪些\r\n  * 阿里Dubbo/HSF\r\n  * 京东JSF\r\n  * 新浪微博Motan\r\n  * 当当网DubboX\r\n* 各微服务框架对比\r\n  * 功能齐全\r\n\r\n## 3、SpringCloud入门概述\r\n\r\n### 1、是什么\r\n\r\n* 官网说明 :SpringCloud,基于SpringBoot提供了一套微服务解决方案, 包括服务注册与发现，配置中心，全链路监控，服务网关，负载均\r\n  衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/springcloud.png?Expires=1594182718&OSSAccessKeyId=TMP.3KkB1rwQ6vEF7zqJYZJ7KKBsAaoSHyaVRt1SY4rc6eVi565YJXbVr5Ct6dfUzjf7qDsEfWvBamrbxWrY49qt8WGPdDuj9w&Signature=6m3spMx3nXVBCCe1Uv21DF%2FnPdg%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/springcloud.png?Expires=1594182718&OSSAccessKeyId=TMP.3KkB1rwQ6vEF7zqJYZJ7KKBsAaoSHyaVRt1SY4rc6eVi565YJXbVr5Ct6dfUzjf7qDsEfWvBamrbxWrY49qt8WGPdDuj9w&Signature=6m3spMx3nXVBCCe1Uv21DF%2FnPdg%3D)\r\n\r\n\r\n* SpringCloud=分布式微服务架构下的一站式解决方案，是个各微服务架构落地技术的几何体，俗称微服务全家桶\r\n\r\n* SpringCloud和SpringBoot是什么关系\r\n\r\n  * Springboot专注于快速方便的开发单个个体微服务\r\n  * SpringCloud是关注全局的微信服务协调整理治理框架，他将Springboot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配偶制管理、服务发现、断路器、路由、微代理、事件总线、全局所、决策竞选、分布式会话等等集成服务\r\n  * Springboot可以离开SpringCloud独立使用开发项目，但SpringCloud离不开Springboot，属于依赖关系\r\n  * Springboot专注于快速、方便的开发但各微服务个体，SpringCloud关注全局的服务治理框架\r\n\r\n* Dubbo是怎么到SpringCloud的？哪些优缺点让你去技术选型\r\n\r\n  * 目前成熟的互联网架构（分布式+服务治理Dubbo）\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/springcloud1.png?Expires=1594182915&OSSAccessKeyId=TMP.3KkB1rwQ6vEF7zqJYZJ7KKBsAaoSHyaVRt1SY4rc6eVi565YJXbVr5Ct6dfUzjf7qDsEfWvBamrbxWrY49qt8WGPdDuj9w&Signature=nQUwUTb6Tj13hCs8sMtXX944Jng%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/springcloud1.png?Expires=1594182915&OSSAccessKeyId=TMP.3KkB1rwQ6vEF7zqJYZJ7KKBsAaoSHyaVRt1SY4rc6eVi565YJXbVr5Ct6dfUzjf7qDsEfWvBamrbxWrY49qt8WGPdDuj9w&Signature=nQUwUTb6Tj13hCs8sMtXX944Jng%3D)\r\n\r\n  * 我们把SpringCloud VS Dubbo 进行对比\r\n\r\n    * 活跃度\r\n\r\n      * https://github.com/dubbo\r\n      * https://github.com/spring-cloud\r\n\r\n|              | Dubbo         | SpringCloud                 |\r\n| ------------ | ------------- | --------------------------- |\r\n| 服务注册中心 | Zookeeper     | SpringCloud Netflix Eureka  |\r\n| 服务调用方式 | RPC           | REST API                    |\r\n| 服务监控     | Dubbo-monitor | SpringBoot Admin            |\r\n| 断路器       | 不完善        | SpringCloud Netflix Hystrix |\r\n| 服务网管     | 无            | SpringCloud Netflix Zuul    |\r\n| 分布式配置   | 无            | SpringCloud Config          |\r\n| 服务跟踪     | 无            | SpringCloud Sleuth          |\r\n| 消息总线     | 无            | SpringCloud Bus             |\r\n| 数据流       | 无            | SpringCloud Stream          |\r\n| 批量任务     | 无            | SpringCloud Task            |\r\n\r\n\r\n\r\n   * 最大区别：SpringCloud抛弃了Dubbo的RPC通信，才用的是基于HTTP的REST方式\r\n   * 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约， 不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。\r\n\r\n* 总结Cloud与Dubbo\r\n    * Dubbo重启维护开发的刘军，主要负责人之一\r\n    * Dubbo的定位始终是一款RPC框架，而SpringCloud的目标是微服务框架的下一站式解决方案\r\n    * 面临微服务基础框架选型时Dubbo与SpringCloud只能是二选一\r\n\r\n### 2、能干嘛\r\n\r\n* Distributed/versioned configuration(分布式/版本控制配置)\r\n* Service registration and discovery(服务注册与发现)\r\n* Routing(路由)\r\n* Service-to-service calls(服务到服务的调用)\r\n* Load balancing(负载均衡配置)\r\n* Circuit Breakers(断路器)\r\n* Distributed messaging(分布式消息管理) \r\n* 。。。。。\r\n\r\n### 3、去哪下\r\n\r\n* 官网：http://progects.spring.io/spring-cloud/\r\n* 参考\r\n  * https://springcloud.cc/spring-cloud-netflix.html 中文API文档\r\n  * API说明\r\n    * https://cloud.spring.io/spring-cloud-static/Dalston.SR1/\r\n    * https://cloud.springcloud.cc/spring-cloud-dalston.html\r\n  * springcloud中文社区 https://springcloud.cn/\r\n  * springcloud中文网 https://springcloud.cc/\r\n\r\n### 4、怎么玩\r\n\r\n* 服务的注册与发现(Eureka)\r\n* 服务消费者(rest+ Ribbon)\r\n* 服务消费者(Feign)\r\n* 断路器(Hystrix)\r\n* 断路器监控(Hystrix Dashboard)\r\n* 路由网关(Zuul)\r\n* 分布式配置中心(Spring Cloud Config)\r\n* 消息总线(Spring Cloud Bus)\r\n* 服务链路追踪(Spring Cloud Sleuth)\r\n  。。。。。\r\n* All:截止到18年4月cloud集成了21种技术\r\n\r\n### 5、SpringCloud国内使用情况\r\n\r\n* 国内公司 \r\n  * 中国联通子公司\r\n  * 华为\r\n  * 视觉中国\r\n  * 拍拍贷\r\n  * 阿里云', 'https://w.wallhaven.cc/full/eo/wallhaven-eo736r.jpg', '19', '1', '0', '2020-09-19 09:17:30', '2020-09-19 09:17:30');
INSERT INTO `blog` VALUES ('37', 'Cloud注册中心', 'SpringCloud', '转载', '<p>Eureka、Zookeeper、Consul注册中心的使用。\n在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者) ,以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中,都会有一个注册中心(存放服务 地址相关信息(接口地址))</p>\n', '## 服务注册中心\r\n\r\n### 一、RestTemplate实现服务调用（并非服务注册中心）\r\n\r\n* RestTemplate配置类\r\n\r\n```java\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.client.RestTemplate;\r\n\r\n@Configuration\r\npublic class ApplicationContextConfig {\r\n\r\n    @Bean\r\n    public RestTemplate getRestTemplate(){\r\n        return new RestTemplate();\r\n    }\r\n\r\n}\r\n```\r\n\r\n* 方法：\r\n\r\n```java\r\n public  static  final  String PAYMENT_URL=\"http://localhost:8001\";\r\n restTemplate.postForObject(PAYMENT_URL+\"/springcloud/payment/save\",payment,R.class);\r\n restTemplate.getForObject(PAYMENT_URL+\"/springcloud/payment/\"+id, R.class);\r\n```\r\n\r\n### 二、Eureka\r\n\r\n#### 1、基础知识\r\n\r\n* 什么是服务治理.\r\n  * Spring Cloud封装了Netflix 公司开发的Eureka模块来实现服务治理在传统的rpc远程调用框架中，管理每 个服务与服务之间依赖关系比较复杂,管理比较复杂,所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等,实现服务发现与注册。\r\n* 什么是服务注册与发现\r\n  * Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。\r\n  * 在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者) ,以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中,都会有一个注册中心(存放服务 地址相关信息(接口地址))\r\n* Eureka包含两个组件: Eureka Server和Eureka Client\r\n  * **Eureka Server**提供服务注册服务：各个微服务节点通过配置启动后,会在EurekaServer中进行注册， 这样EurekaServer中的服务注册表中将会存储所有 可用服务节点的信息，服务节点的信息可以在界面中直观看到。\r\n  * **EurekaClient**通过注册中心进行访问：是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、 使用轮询(round-robin)负载算法的负载均衡器。在应用启动后,将会向Eureka Server发送心跳(默认周期为30秒)。 如果Eureka Server在多个心跳周期内没有接收到某个节点的心\r\n    跳，EurekaServer将 会从服务注册表中把这个服务节点移除(默认90秒)。\r\n* 调用流程\r\n  * 1、先启动eureka注册中心\r\n  * 2、启动服务提供者paymen支付服务\r\n  * 3、支付服务启动后会把自身信息(比如服务地址以别名方式注册进eureka)\r\n  * 4、消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址\r\n  * 5、消费者获得调用地址后，底层实际是利用H ttpClien技术,实现远程调用\r\n  * 6、消费者获得服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新一次服务调用地址\r\n\r\n#### 2、单机Eureka构建步骤\r\n\r\n* 导入pom文件\r\n\r\n```xml\r\n    <dependencies>\r\n        <!--服务端-->\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server -->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\r\n        </dependency>\r\n        <!--注册端-->\r\n         <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-client -->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <!--依赖的pom-->\r\n         <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-actuator</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n```\r\n\r\n* 配置yml文件\r\n\r\n```properties\r\nserver:\r\n  port: 7001\r\n\r\neureka:\r\n  instance:\r\n   hostname: localhost  #eureka服务端的实例名字\r\n  client:\r\n    register-with-eureka: false    #表识不向注册中心注册自己\r\n    fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\r\n    service-url:\r\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\r\n\r\n```\r\n\r\n* 启动类\r\n\r\n```java\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\r\n\r\n@SpringBootApplication\r\n@EnableEurekaServer //表示eureka自身服务  @EnableEurekaClient表示注册用户\r\npublic class EurekaMain7001 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(EurekaMain7001.class,args);\r\n    }\r\n}\r\n```\r\n\r\n* **<b style=\"color:red\">坑：记得一定药把yml的层次分明还有连接前后不要有空格</b>**\r\n\r\n#### 3、 Eureka集群构建\r\n\r\n* 问题：微服务RPC远程服务调用最核心的是什么？\r\n\r\n  * 高可用，试想如果你的注册中心只有一个only one，他出故障了那就呵呵(￣▽￣)\"了，会导致整个服务环境不可用，所以核心是高可用\r\n  * 解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错\r\n\r\n* 原理：互相注册，相互守望\r\n\r\n* 集群环境搭建\r\n\r\n  * 单机玩法：修改映射配置文件\r\n\r\n    * 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件\r\n\r\n    * 添加映射配置：127.0.0.1 eureka7001.com\r\n\r\n      ​						   127.0.0.1 eureka7002.com\r\n\r\n  * 集群server的yml文件配置\r\n\r\n  ```properties\r\n  server:\r\n    port: 7001\r\n  \r\n  eureka:\r\n    instance:\r\n     hostname: eureka7001.com  #eureka服务端的实例名字\r\n    client:\r\n      register-with-eureka: false    #表识不向注册中心注册自己\r\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\r\n      service-url:\r\n        defaultZone: http://eureka7002.com:7002/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\r\n  	#7001和7002互相注册\r\n  ```\r\n\r\n  * 集群client的yml文件配置\r\n\r\n\r\n  ```properties\r\n  server:\r\n    port: 80\r\n  \r\n  spring:\r\n    application:\r\n      name: cloud-order-service\r\n  \r\n  eureka:\r\n    client:\r\n      #表示是否将自己注册斤EurekaServer默认为true\r\n      register-with-eureka: true\r\n      # 是否从EurekaServer抓取以有的注册信息，默认为true。系欸但无所谓，集群必须设置为true才能配合ribbon使用负载均衡\r\n      fetchRegistry: true\r\n      service-url:\r\n        #defaultZone: http://localhost:7001/eureka\r\n        defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\r\n       #分别把80服务注册进两个eureka服务中\r\n  \r\n  \r\n  ```\r\n\r\n  * 配置好之后把原先方法里边写死的端口改成Eureka服务名称\r\n\r\n  ```java\r\n  public  static  final  String PAYMENT_URL=\"http://CLOUD-PAYMENT-SERVICE\";\r\n  ```\r\n\r\n  * 配置类也要修改加上：@LoadBalanced注解意味这开启负载均衡功能\r\n    * 负载均衡：主要采用的轮询算法\r\n\r\n* 检测client是否启动：http://localhost:8001/actuator/health\r\n\r\n* 完善信息\r\n\r\n```properties\r\n  instance:\r\n    instance-id: payment8002 #status的对应名字\r\n    prefer-ip-address: true  #显示服务对应ip地址\r\n```\r\n\r\n#### 4、服务发现DIscovery\r\n\r\n* 对于注册进eureka里边的微服务，可以通过服务发现获得该服务的信息\r\n\r\n* 修改Controller层\r\n\r\n* 启动类上加上：@EnableDiscoveryClient注解\r\n\r\n  ```java\r\n     @GetMapping(value = \"/payment/discovery\")\r\n      public Object discovery(){\r\n          //获取服务清单列表\r\n          List<String> services = discoveryClient.getServices();\r\n          for (String service : services) {\r\n              log.info(\"********element\"+service);\r\n          }\r\n          List<ServiceInstance> instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\");//获取服务名下的具体服务\r\n          for (ServiceInstance instance : instances) {\r\n              log.info(instance.getServiceId()+\"\\t\"+instance.getHost()+\"\\t\"+instance.getPort()+\"\\t\"+instance.getUri());\r\n          }\r\n          return this.discoveryClient;\r\n      }\r\n  ```\r\n\r\n* 输出结果：\r\n\r\n```java\r\n2020-07-12 09:07:21.320  INFO 956 --- [nio-8001-exec-2] c.r.s.controller.PaymentController       : CLOUD-PAYMENT-SERVICE	192.168.159.1	8002	http://192.168.159.1:8002\r\n2020-07-12 09:07:21.320  INFO 956 --- [nio-8001-exec-2] c.r.s.controller.PaymentController       : CLOUD-PAYMENT-SERVICE	192.168.159.1	8001	http://192.168.159.1:8001\r\n```\r\n\r\n#### 5、Eureka的自我保护\r\n\r\n* 概述：保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式,Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\r\n\r\n* 导致原因：\r\n\r\n  * 某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存\r\n  * 在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。（好死不如赖活着）\r\n  * 属于CAP里边的AP分支\r\n\r\n* 怎么禁止自我保护\r\n\r\n  * enable-self- preservation:ture 默认是开启的 \r\n\r\n  * evi ction- interval-timer- in-ms: 2000 缓存时间是2s\r\n\r\n  * 客户端：\r\n\r\n   * Eureka客户端向服务端发送心跳的时间间隔，单位为秒( 默认是30秒):lease-renewal- interval- in-seconds: 1\r\n   * Eureka服:务端在收到最后一次心跳后等待时间上限，单位为秒( 默认是90秒)超时将剔除服务:lease-expiration-duration-in-seconds: 2\r\n\r\n      如果注册服务挂掉在2s内没有再次向服务端发送心跳服务端将会立马清理掉该服务\r\n\r\n### 三、Zookeeper\r\n\r\n#### 1、注册中心Zookeeper\r\n\r\n以zookeeper-3.4.9为例\r\n\r\n* zookeeper是一个分布式协调工具，可以实现注册中心\r\n  * 准备：关闭Linux服务器防火墙（systemctl stop firewalld），启动zookeeper\r\n  * zookeeper服务器取代Eureka服务器，zk作为服务注册中心\r\n\r\n#### 2、构建服务\r\n\r\n* 引入依赖\r\n\r\n```xml\r\n <dependencies>\r\n\r\n        <dependency>\r\n            <groupId>com.atguigu.springcloud</groupId>\r\n            <artifactId>cloud-api-commons</artifactId>\r\n            <version>${project.version}</version>\r\n        </dependency>\r\n\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-actuator</artifactId>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery -->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-devtools</artifactId>\r\n            <scope>runtime</scope>\r\n            <optional>true</optional>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test -->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n\r\n\r\n    </dependencies>\r\n\r\n```\r\n\r\n* 如果jar版本冲突替换\r\n\r\n```xml\r\n <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery -->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\r\n            <!--排除zk3.5.3-->\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.apache.zookeeper</groupId>\r\n                    <artifactId>zookeeper</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n            <!--添加zk 3.4,9版本-->\r\n        <!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper -->\r\n        <dependency>\r\n            <groupId>org.apache.zookeeper</groupId>\r\n            <artifactId>zookeeper</artifactId>\r\n            <version>3.4.9</version>\r\n        </dependency>\r\n\r\n```\r\n\r\n\r\n\r\n* 配置yml\r\n\r\n```properties\r\nserver:\r\n  port: 8004 # 服务端口\r\n\r\nspring:\r\n  application:\r\n    name: cloud-provider-payment  #服务名\r\n  cloud:\r\n    zookeeper:\r\n      connect-string: 192.168.136.140:2181 #连接zookeeper的ip+端口\r\n\r\n```\r\n\r\n* 启动类 加注解：@EnableDiscoveryClient\r\n  * 该注解用于向使用consul或者zookeeper作为注册中心时注册服务\r\n* controller测试\r\n\r\n```java\r\npackage com.atguigu.springcloud.controller;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.UUID;\r\n\r\n@RestController\r\n@Slf4j\r\npublic class PaymentController {\r\n\r\n    @Value(\"${server.port}\")\r\n    private String serverPort;\r\n\r\n    @GetMapping(value = \"/payment/zk\")\r\n    public String paymentzk(){\r\n        return \"springcloud with zookeeper:\"+serverPort+\"\\t\"+ UUID.randomUUID().toString();\r\n    }\r\n\r\n}\r\n \r\n \r\n\r\n```\r\n\r\n#### 3、思考对比\r\n\r\n* zookeeper的注册进来的节点是持久的还是临时的？\r\n  * 临时的，比eureka冷酷一点\r\n\r\n### 四、Consul\r\n\r\n### 1、简介\r\n\r\n* Consul是一开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发。\r\n* 提供了微服务系统中的服务治理、I配置中心、控制总线等功能。这些功能中的每一个 都可以根据需要单独使用,也可以一-起使用以构建全方位的服务网格,总之Consul提供了- -种完整的服务网格解决方案。\r\n* 它具有很多优点。包括:紆raft 协议，比较简洁;支持健康检查,同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台,支持Linux、Mac、 Windows\r\n\r\n| 功能       | 介绍                                             |\r\n| ---------- | ------------------------------------------------ |\r\n| 服务发现   | 提供HTTP和DNS两种发现方式                        |\r\n| 健康检测   | 支持多种协议，HTTP、TCP、Docker、Shell脚本定制化 |\r\n| KV存储     | Key、Value的存储方式                             |\r\n| 多数据中心 | Consul支持多数据中心                             |\r\n\r\n* 可视化web界面\r\n\r\n#### 2、安装\r\n\r\n* 官网安装说明 https://www.consul.io/downloads.html\r\n\r\n### 3、启动\r\n\r\n* consul agent -dev\r\n\r\n#### 4、构建服务\r\n\r\n* pom\r\n\r\n```xml\r\n        <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery -->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\r\n        </dependency>\r\n```\r\n\r\n* yml\r\n\r\n```xml\r\nserver:\r\n  port: 80\r\n\r\n\r\nspring:\r\n  application:\r\n    name: consul-consumer-order\r\n  cloud:\r\n    consul:\r\n      host: localhost\r\n      port: 8500\r\n      discovery:\r\n        service-name: ${spring.application.name}\r\n```\r\n\r\n* 启动类注解\r\n\r\n  * ```java\r\n    @EnableEurekaClient\r\n    ```\r\n\r\n### 总结:\r\n\r\n#### 对比Eureka、Zookeeper、Consul\r\n\r\n| 组件名    | 语言 | 服务健康检测 | 对外暴露接口 | SpringCloud集成 |\r\n| --------- | ---- | ------------ | ------------ | --------------- |\r\n| Eureka    | Java | AP           | HTTP         | 已集成          |\r\n| Consul    | Go   | CP           | HTTP/DNS     | 已集成          |\r\n| Zookeeper | Java | CP           | 客户端       | 已集成          |\r\n\r\n* C:Consistency（强一致性）一致性\r\n* A：Availability（可用性） 高可用\r\n* P:Partition tolerance(分区容错性) 容错性\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'https://w.wallhaven.cc/full/96/wallhaven-96jl7d.jpg', '9', '1', '0', '2020-09-19 09:18:51', '2020-09-19 09:18:51');
INSERT INTO `blog` VALUES ('38', 'Cloud服务调用', 'springcloud', '转载', '<p>Ribbon、Feign、OpenFeign\r\n调用注册中心里边稳定服务，还有负载均衡的实现、轮询算法。</p>\r\n\r\n<p>     </p>\r\n<p>     </p>\r\n<p>     </p>', '## 服务调用\r\n\r\n###  一、Ribbon\r\n\r\n#### 1、概述\r\n\r\n* Spring Cloud Ribbon是基于Netflix Ribboh实现的一套客户端负载均衡的工具。\r\n* 简单的说，Ribbon是Netflix发布的开源项目， 主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供- 系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer (简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询,随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。\r\n* 目前已经进入部署，但是目前主流还是ribbon\r\n* LB负载均衡(Load Balance)是什么\r\n  * 简单的说就是将用户的请求平摊的分配到多个服务上,从而达到系统的HA (高可用)。\r\n  * 常见的负载均衡有软件Nginx, LVS, 硬件F5等。\r\n* Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别\r\n  * Nginx是服务器负载均衡，客F端所有请求都会交给nginx,然后由nginx实现转发请求。即负载均衡是由服务端实现的。\r\n  * Ribbon本地负载均衡，在调用微服务接口时候,会在注册中心上获取注册信息服务列表之后缓存到JVM本地,从而在本地实现RPC远程服务调用技术。\r\n* **LB（负载均衡）**\r\n  * 集中式LB\r\n    * 即在服务的消费方和提供方之间使用独立的LB设施可以是硬件,如F5, 也可以是软件,如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方;\r\n  * 进程内LB\r\n    * 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用,然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB,它只是-个库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\r\n* Ribbon在工作时分成两步\r\n  * 第一步先选择EurekaServer ,它优先选择在同-个区域内负载较少的server.\r\n  * 第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。\r\n  * 其中Ribbon提供了多种策略:比如轮询、随机和根据响应时间加权。\r\n\r\n#### 2、负载均衡演示\r\n\r\n* pom\r\n```xml\r\n<dependency>\r\n      <groupId>org.springframework.cloud</groupId>\r\n      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n </dependency>\r\n<!--spring-cloud-starter-netflix-eureka-client就包含了ribbon-->\r\n```\r\n* getForObject方法/getForEntity方法\r\n\r\n[![](https://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8.png?Expires=1595058846&OSSAccessKeyId=TMP.3KikgrMgKshXzBFc6kWth5vPd2WQR7YwsvisQxsoqn7HcwwLWH4tPVBaBRAKeL2tj7R8LEhu1Cg9BBthsJnfUuvKG3j1jM&Signature=KDPuIm%2BlygcOVSmL3a1zdKMj4Ik%3D)](https://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8.png?Expires=1595058846&OSSAccessKeyId=TMP.3KikgrMgKshXzBFc6kWth5vPd2WQR7YwsvisQxsoqn7HcwwLWH4tPVBaBRAKeL2tj7R8LEhu1Cg9BBthsJnfUuvKG3j1jM&Signature=KDPuIm%2BlygcOVSmL3a1zdKMj4Ik%3D)\r\n\r\n* postForObject/postForEntity方法\r\n\r\n[![](https://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A82.png?Expires=1595058863&OSSAccessKeyId=TMP.3KikgrMgKshXzBFc6kWth5vPd2WQR7YwsvisQxsoqn7HcwwLWH4tPVBaBRAKeL2tj7R8LEhu1Cg9BBthsJnfUuvKG3j1jM&Signature=KoQ8NCJsjK7NxoaG7AO2zm8GSuk%3D)](https://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A82.png?Expires=1595058863&OSSAccessKeyId=TMP.3KikgrMgKshXzBFc6kWth5vPd2WQR7YwsvisQxsoqn7HcwwLWH4tPVBaBRAKeL2tj7R8LEhu1Cg9BBthsJnfUuvKG3j1jM&Signature=KoQ8NCJsjK7NxoaG7AO2zm8GSuk%3D)\r\n\r\n\r\n#### 3、核心组件IRule\r\n\r\n* 根据特定算法从服务列表中选取一个要访问的服务\r\n\r\n\r\n\r\n| 实现                                    | 描述                                                         |\r\n| --------------------------------------- | ------------------------------------------------------------ |\r\n| com.netflix.loadbalancer.RoundRobinRule | 轮询                                                         |\r\n| com.netflix.loadbalancer.RandomRule     | 随机                                                         |\r\n| com.netflix.loadbalancer.RetryRule      | 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试 |\r\n| WeightedResponse TimeRule               | 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 |\r\n| BestAvailableRule                       | 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择-个并发量最小的服务 |\r\n| AvailabilityFilteringRule               | 先过滤掉故障实例，再选择并发较小的实例                       |\r\n| ZoneAvoidanceRule                       | 默认规则，复合判断server所在区域的性能和server的可用性选择服务器 |\r\n\r\n* 替换轮询算法：编写配置类\r\n  * 方文档明确给出了警告:\r\n  * 这个自定，义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，I\r\n  * 否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享,达不到特殊化定制的目的了。\r\n\r\n* 配置类写法：\r\n\r\n```java\r\npackage com.rw.myruler;\r\n\r\nimport com.netflix.loadbalancer.IRule;\r\nimport com.netflix.loadbalancer.RandomRule;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class MySelfRuler {\r\n    @Bean\r\n    public IRule myRule() {\r\n        return new RandomRule(); //定义为随机\r\n    }\r\n}\r\n\r\n```\r\n\r\n* 启动类读取配置文件\r\n\r\n```java\r\n@RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\",configuration = MySelfRuler.class)\r\n```\r\n\r\n#### 4、负载均衡算法\r\n\r\n* rest接口第几次请求数%服务器集群总数量=实际调用服务器位置下标，没此服务重启后rest接口计数从1开始\r\n\r\n[![](https://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png?Expires=1595058925&OSSAccessKeyId=TMP.3KikgrMgKshXzBFc6kWth5vPd2WQR7YwsvisQxsoqn7HcwwLWH4tPVBaBRAKeL2tj7R8LEhu1Cg9BBthsJnfUuvKG3j1jM&Signature=PdYzje%2B2LpXACf2f2am6rFv2BO4%3D)](https://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png?Expires=1595058925&OSSAccessKeyId=TMP.3KikgrMgKshXzBFc6kWth5vPd2WQR7YwsvisQxsoqn7HcwwLWH4tPVBaBRAKeL2tj7R8LEhu1Cg9BBthsJnfUuvKG3j1jM&Signature=PdYzje%2B2LpXACf2f2am6rFv2BO4%3D)\r\n\r\n* 手写轮询算法：JUC（CAS+自旋锁）\r\n\r\n### 二、OpenFegin\r\n\r\n### 1、fegin\r\n\r\n#### (1)是什么？\r\n\r\n* Feign是一个声明式WebService客户端。 使用Feign能让编写Web Service客户端更加简单。\r\n* 它的使用方法是定义一个服务接口然后在上面添注解。Feign也支 持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支 负载均衡\r\n\r\n#### （2）能干嘛？\r\n\r\n* Feign能干什么\r\n  * **Feign旨在使编写Java Http客户端变得更容易。**\r\n  * 前面在使用Ribbon+ RestTemplate时,利用RestTemplate对http请求的封装处理，形成了-套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一-处，往往-一个接会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装， 由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下， 我们只需创建一 个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解，现在是一 个微服务接口上面标注一 个Feign注解即可)，即阿完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\r\n  * **Feign集成了Ribbon**\r\n    利用Ribbon维护了Payment的服务列表信息，且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是,通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用\r\n* fegin和openfegin的区别\r\n\r\n| Fegin                                                        | OpenFegin                                                    |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon,用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口就可以调用服务注册中心的服务 | OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。 |\r\n| <dependency><br/><groupId>org . springframework. cloud</ groupId><br/><artifactId>spring-cloud-starter-feign</artifactId><br/></dependency> | <dependency><br/><groupId>org. springframework. cloud</ groupId><br/><artifactId>spring-C loud-starter-openfeign</artifactId><br/></ dependency> |\r\n\r\n### 2、OpenFegin使用步骤\r\n\r\n使用openFegin实现面向接口编程\r\n\r\n#### （1）接口+注解\r\n\r\n* 微服务调用接口+@FeignClient\r\n\r\n#### （2）POM\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign -->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n    <version>2.2.1.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n#### （3）YML\r\n\r\n```properties\r\nserver:\r\n  port: 80\r\neureka:\r\n  client:\r\n    register-with-eureka: false\r\n    service-url:\r\n      defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka\r\n \r\n\r\n```\r\n\r\n\r\n\r\n#### （4）主启动类\r\n\r\n* ```java\r\n  package com.rw.springcloud;\r\n  \r\n  import org.springframework.boot.SpringApplication;\r\n  import org.springframework.boot.autoconfigure.SpringBootApplication;\r\n  import org.springframework.cloud.netflix.eureka.EnableEurekaClient;\r\n  import org.springframework.cloud.openfeign.EnableFeignClients;\r\n  import springfox.documentation.swagger2.annotations.EnableSwagger2;\r\n  \r\n  @SpringBootApplication\r\n  @EnableFeignClients(basePackages = \"com.rw.springcloud.service\")\r\n  @EnableEurekaClient\r\n  @EnableSwagger2\r\n  public class OrderFeignMain80 {\r\n      public static void main(String[] args) {\r\n          SpringApplication.run(OrderFeignMain80.class,args);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n#### （5）业务类\r\n\r\n- 业务逻辑接口+@FeginClient配置调用provider服务\r\n- 新建PaymentFeginService接口并新增注解@FeginClient\r\n\r\n```java\r\npackage com.rw.springcloud.service;\r\n\r\nimport com.rw.springcloud.utils.R;\r\nimport org.springframework.cloud.openfeign.FeignClient;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\n// 大坑！！ \r\n@FeignClient(name = \"CLOUD-PAYMENT-SERVICE\")\r\npublic interface PaymentFeignService {\r\n    //必须使用@RequestMapping,不能使用@GetMapping\r\n    //@PathVariable 必须指定参数名称\r\n    @RequestMapping(method = RequestMethod.GET,value = \"/springcloud/payment/{id}\")\r\n    public R save(@PathVariable(\"id\") long id);\r\n}\r\n\r\n```\r\n\r\n* 控制层Controller\r\n\r\n```java\r\npackage com.rw.springcloud.controller;\r\nimport com.rw.springcloud.service.PaymentFeignService;\r\nimport com.rw.springcloud.utils.R;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.bind.annotation.*;\r\n/**\r\n * <p>\r\n *  前端控制器\r\n * </p>\r\n *\r\n * @author Ruiwen\r\n * @since 2020-07-10\r\n */\r\n@RestController\r\npublic class PaymentController {\r\n    @Autowired\r\n    private PaymentFeignService paymentFeignService;\r\n    @GetMapping(\"/consumber/payment/get/{id}\")\r\n    public R save(@PathVariable(\"id\") long id){\r\n        return paymentFeignService.save(id);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n#### （6）Feign自带负载均衡配置项\r\n\r\n###  3、OpenFegin超时控制\r\n\r\n#### （1）OpenFegin默认等待一秒，超过就报超时错误\r\n\r\n* 超时配置\r\n\r\n```properties\r\n#设置feign客户端超时时间（opengeign默认支持ribbon）\r\nribbon:\r\n  #指的是建立连接所用的时间，是用于网络状况正常的情况下，两端连接所用的时间\r\n  ReadTimeout:  5000  # 5s\r\n  # 指的是建立连接后从服务启读取到可用资源所用的时间\r\n  ConnectTimeout: 5000\r\n```\r\n\r\n### 4、OpenFegin日志打印功能\r\n\r\n#### (1)日志级别\r\n\r\n* NONE:默认的，不显示任何日志;\r\n* BASIC:仅记录请求方法、URL、 响应状态码及执行时间;\r\n* HEAD[ERS:除了BASIC中定义的信息之外,还有请求和响应的头信息;\r\n* FULL:除了IHEADERS中定义的信息之外，还有请求和响应的正文及元数据。\r\n\r\n#### （2）配置类\r\n\r\n```java\r\npackage com.rw.springcloud.config;\r\n\r\nimport feign.Logger;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class FeignConfig {\r\n\r\n    @Bean\r\n    Logger.Level feignLoggerLevel(){\r\n        return Logger.Level.FULL;\r\n    }\r\n}\r\n \r\n\r\n```\r\n\r\n####  (3)yml中开启日志的fegin客户端\r\n\r\n\r\n\r\n```properties\r\nlogging:\r\n  level:\r\n    com.atguigu.springcloud.service.PaymentFeignService: debug\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'https://w.wallhaven.cc/full/vg/wallhaven-vgwkm8.jpg', '11', '1', '0', '2020-09-19 09:24:56', '2020-09-19 09:24:56');
INSERT INTO `blog` VALUES ('39', 'Hystrix服务降级、熔断', 'springcloud', '转载', '<p>Hystrix是一 个用于处理分布式系统的延迟和容错的开源库,在分布式系统里,许多依赖不可避免的会调用失败,比如超时、异常等,\r\nHystrix能够保证在一 个依赖出问题的情况下，不会导致整体服务失败,避免级联故障,以提高分布式系统的弹性。</p>\r\n', '## 服务降级\r\n\r\n### 一、Hystrix\r\n\r\n#### 1、分布式系统面临的问题\r\n\r\n* 复杂分布式体系结构中的应用程序又数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\r\n* eg:一个请求需要调用A,P,H,I四个服务，如果一切顺利则没有什么问题，关键如果中间某个服务超时会出现什么情况？**-->服务雪崩**\r\n* 服务雪崩\r\n  * 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。\r\n    如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃,所\r\n    谓的“雪崩效应”\r\n  * 对于高流量的应用来说，单一的后端依赖可能会 导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还\r\n    可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延\r\n    迟进行隔离和管理，以便单个依赖关系的失败,不能取消整个应用程序或系统。\r\n    所以,\r\n  * 通常当你发现-个模块下的某个实例失败后,这时候这个模块依然还会接收流量,然后这个有问题的模块还调用了其他的模块,这样就\r\n    会钹生级联故障，或者叫雪崩。\r\n\r\n#### 2、Hystrix是什么？\r\n\r\n* Hystrix是一 个用于处理分布式系统的延迟和容错的开源库,在分布式系统里,许多依赖不可避免的会调用失败,比如超时、异常等,\r\n  Hystrix能够保证在一 个依赖出问题的情况下，不会导致整体服务失败,避免级联故障,以提高分布式系统的弹性。\r\n* “断路器”本身是一种开关装置,当某个服务单元发生故障之后, 通过断路器的故障监控(类似熔断保险丝)，向调用方返回一个符合\r\n  预期的、可处理的备选响应(FallBack) ，而不是长时间的等待或者抛出调用方无法处理的异常,这样就保证了服务调用方的线程不会\r\n  被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\r\n\r\n#### 3、重要概念\r\n\r\n##### （1）服务降级 fallback\r\n\r\n* 服务器忙，请稍后再试，不让客户端等待，并立刻返回一个友好提示，fallback\r\n* 哪些情况会触发降级\r\n  * 程序运行异常\r\n  * 超时\r\n  * 服务熔断触发服务降级\r\n  * 线程池/信号量打满也会导致服务降级\r\n\r\n##### （2）服务熔断 break\r\n\r\n* 类似保险丝达到最大服务访问量后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示\r\n* 就是保险丝\r\n\r\n##### （1）服务限流 flowlimit\r\n\r\n* 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排对，一秒钟N个，有序进行\r\n\r\n##### \r\n\r\n#### 3、Hystrix案例\r\n\r\n##### （1）pom\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix -->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\r\n    <version>2.2.1.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n##### （2）yml\r\n\r\n```properties\r\nserver:\r\n  port: 8001\r\n\r\n\r\neureka:\r\n  client:\r\n    register-with-eureka: true    #表识不向注册中心注册自己\r\n    fetch-registry: true   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\r\n    service-url:\r\n      # defaultZone: http://eureka7002.com:7002/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\r\n      defaultZone: http://eureka7001.com:7001/eureka/\r\n#  server:\r\n#    enable-self-preservation: false\r\nspring:\r\n  application:\r\n    name: cloud-provider-hystrix-payment\r\n  #    eviction-interval-timer-in-ms: 2000\r\n\r\n\r\n```\r\n\r\n\r\n\r\n##### （3）Jmeter并发测试\r\n\r\n* 请求一个接口另一个也会被拖累，最终倒是服务端8001直接被拖死\r\n\r\n##### （4）故障导致\r\n\r\n* 用Jmeter高并发去压超时接口 正常的接口会受影响出现超时或者请求变慢\r\n* 因为tomcat线程池里面的工作线程已经被挤占完毕\r\n* 正因为又上述故障或不佳表现才有我们的降级/容错/限流技术诞生\r\n\r\n##### （5）如何解决？解决的要求\r\n\r\n* 超时导致服务器变慢（转圈）\r\n  * 超时不再等待\r\n* 出错（宕机或程序运行出错）\r\n  * 出错要有兜底\r\n* 解决\r\n  * 对方服务(8001)超时了，调用者(80)不能- -直卡死等待，必须有服务降级\r\n  * 对方服务(8001)down机了，调用者(80)不能一-直 卡死等待，必须有服务降级\r\n  * 对方服务（8001）OK，调用者（80）自己故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级\r\n\r\n\r\n\r\n##### （6）服务降级 fallback\r\n\r\n* 降级配置 @HystrixCommand\r\n* 先从自身找问题\r\n  * 设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作为服务降级的fallback\r\n* 8001fallback（服务端降级）\r\n  * 业务类启用 @HystrixCommand报异常后如何处理\r\n    * 一旦调用服务失败并跑哦出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法\r\n  * 主启动类激活\r\n    * @EnableCircuitBreaker\r\n\r\n```java\r\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",commandProperties = {\r\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\" , value=\"3000\")\r\n    })\r\n    public R paymentInfo_TimeOut(Integer id){\r\n        //暂停几秒线程\r\n        int timeNumber=5;\r\n//        try { TimeUnit.SECONDS.sleep(timeNumber); }catch (InterruptedException e){\r\n//           e.printStackTrace();\r\n//        }\r\n        int age=10/0;\r\n        return R.ok().data(\"data\",\"线程池\"+Thread.currentThread().getName()+\r\n                \"paymentInfo_TimeOut,id\"+id+\"\\t\"+\"O(∩_∩)O嘿嘿~\" +\"耗时(s)\"+timeNumber);\r\n    }\r\n\r\n    public R paymentInfo_TimeOutHandler (Integer id){\r\n        return R.ok().data(\"data\",\"线程池\"+Thread.currentThread().getName()+\r\n                \"paymentInfo_TimeOutHandler,id\"+id+\"\\t\"+\"O(！^！)\" );\r\n    }\r\n```\r\n\r\n\r\n\r\n* 80 fallback（客户端降级）\r\n\r\n  * yml\r\n\r\n  ```properties\r\n  #feign开启对hystrix的支持\r\n  feign:\r\n    hystrix:\r\n      enabled: true\r\n  ```\r\n\r\n  * 启动类：@EnableHystrix\r\n  * controller\r\n\r\n  ```java\r\n      @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",commandProperties = {\r\n              @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value = \"1500\")\r\n      })\r\n      @GetMapping(\"/payment/hystrix/timeout/{id}\")\r\n      public R paymentInfo_TimeOut(@PathVariable(\"id\") Integer id){\r\n          return hystrixService.paymentInfo_TimeOut(id);\r\n      }\r\n      public R paymentInfo_TimeOutHandler (Integer id){\r\n          return R.ok().data(\"data\",\"线程池\"+Thread.currentThread().getName()+\r\n                  \"我是消费者，对方支付系统繁忙请10s后再试或者自己运行出错请检查自己O(！^！)\" );\r\n      }\r\n  ```\r\n\r\n  * 这样配置当客户端调用服务端自身出错时或者服务端响应时间超过自己定义等待时间时就会到paymentInfo_TimeOutHandler方法中\r\n\r\n* 目前问题：\r\n\r\n  * 每个业务方法对应一个兜底的方法，代码膨胀\r\n  * 统一和自定义的分开\r\n\r\n* 解决问题\r\n\r\n  * 每个方法配置一个？？？膨胀\r\n\r\n    * feign接口系列\r\n    * @ DefaultProperties(defaultFallback = \"\")\r\n    * controller配置\r\n\r\n    ```java\r\n    package com.rw.springcloud.controller;\r\n    \r\n    @RestController\r\n    @Slf4j\r\n    @DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\r\n    //配置了全局默认的 方法上只需要写@HystrixCommand 就默认执行出错的方法，如果不写的话就和服务降级没关系，也可以针对的实现私人定制\r\n    public class OrderHystrixController {\r\n        @Autowired\r\n        private PaymentHystrixService hystrixService;\r\n    \r\n        @GetMapping(\"/payment/hystrix/ok/{id}\")\r\n        public R paymentInfo_OK(@PathVariable(\"id\") Integer id){\r\n            return hystrixService.paymentInfo_OK(id);\r\n        }\r\n    \r\n    //    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",commandProperties = {\r\n    //            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value = \"1500\")\r\n    //    })\r\n        @HystrixCommand\r\n        @GetMapping(\"/payment/hystrix/timeout/{id}\")\r\n        public R paymentInfo_TimeOut(@PathVariable(\"id\") Integer id){\r\n            return hystrixService.paymentInfo_TimeOut(id);\r\n        }\r\n        public R paymentInfo_TimeOutHandler (Integer id){\r\n            return R.ok().data(\"data\",\"线程池\"+Thread.currentThread().getName()+\r\n                    \"我是消费者，对方支付系统繁忙请10s后再试或者自己运行出错请检查自己O(！^！)\" );\r\n        }\r\n        //全局fallback\r\n        public R payment_Global_FallbackMethod(){\r\n            return R.error().message(\"Global异常处理信息，请稍后再试！\");\r\n        }\r\n    }\r\n    \r\n    ```\r\n\r\n    \r\n\r\n  * 和业务逻辑混一起？？？混乱\r\n\r\n    * 对feign接口添加解耦类\r\n    * 要面对的异常\r\n      * 运行异常\r\n      * 超时异常\r\n      * 突然宕机\r\n    * 处理，配置统一的异常处理类PaymentFallbackService\r\n\r\n    ```java\r\n    package com.rw.springcloud.service;\r\n    \r\n    import com.rw.springcloud.utils.R;\r\n    import org.springframework.stereotype.Component;\r\n    \r\n    @Component\r\n    public class PaymentFallbackService  implements PaymentHystrixService {\r\n        @Override\r\n        public R paymentInfo_OK(Integer id) {\r\n            return R.ok().message(\"PaymentFallbackService--paymentInfo_OK--fallback\");\r\n        }\r\n    \r\n        @Override\r\n        public R paymentInfo_TimeOut(Integer id) {\r\n            return R.ok().message(\"PaymentFallbackService--paymentInfo_TimeOut--fallback\");\r\n        }\r\n    }\r\n    \r\n    ```\r\n\r\n    * feign接口做统一处理\r\n\r\n    ```java\r\n    package com.rw.springcloud.service;\r\n    \r\n    import com.rw.springcloud.utils.R;\r\n    import org.springframework.cloud.openfeign.FeignClient;\r\n    import org.springframework.stereotype.Component;\r\n    import org.springframework.web.bind.annotation.GetMapping;\r\n    import org.springframework.web.bind.annotation.PathVariable;\r\n    \r\n    @Component\r\n    @FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\",fallback = PaymentFallbackService.class)\r\n    public interface PaymentHystrixService {\r\n        @GetMapping(\"/payment/hystrix/ok/{id}\")\r\n        public R paymentInfo_OK(@PathVariable(\"id\") Integer id);\r\n        @GetMapping(\"/payment/hystrix/timeout/{id}\")\r\n        public R paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\r\n    }\r\n    \r\n    ```\r\n\r\n    * 这样处理后就统一配置了服务降级，客户端宕机、超时、报错都会走fallback方法，如果实现controller私人定制的话还是走私人定制的fallback\r\n\r\n##### （7）服务熔断 break\r\n\r\n* 断路器：一句话就是家里的保险丝\r\n\r\n* 熔断是什么\r\n\r\n  * 熔断机制概述\r\n  * 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时,会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。\r\n    **当检测到该节点微服务调用响应正常后,恢复调用链路。**\r\n  * 在Spring Cloud框架里,熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值, 缺省是5秒内20次调用失败,就会启动熔断机制。熔断机制的注解是@HystrixCommand.\r\n\r\n* 实操\r\n\r\n  * 在8001provider测试\r\n  * service\r\n\r\n  ```java\r\n   /**\r\n       * =====服务熔断\r\n       */\r\n      @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\r\n              @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),  //是否开启断路器\r\n              @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),   //请求次数\r\n              @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),  //时间范围\r\n              @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"), //失败率达到多少后跳闸\r\n      })\r\n      public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\r\n          if (id < 0){\r\n              throw new RuntimeException(\"*****id 不能负数\");\r\n          }\r\n          String serialNumber = IdUtil.simpleUUID();\r\n  \r\n          return Thread.currentThread().getName()+\"\\t\"+\"调用成功,流水号：\"+serialNumber;\r\n      }\r\n      public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id){\r\n          return \"id 不能负数，请稍候再试,(┬＿┬)/~~     id: \" +id;\r\n      }\r\n  ```\r\n\r\n  * controller\r\n\r\n  ```java\r\n    //服务熔断\r\n      @GetMapping(\"/payment/circuit/{id}\")\r\n      public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\r\n          return paymentService.paymentCircuitBreaker(id);\r\n      }\r\n  ```\r\n\r\n  效果：错误率达到配置的错误率后服务开始断开就算请求正确的也会走fallback方法，直到错误率逐渐下降，服务恢复\r\n\r\n* 原理\r\n\r\n  * 熔断打开：请求不再进行调用当前服务，内部设置时钟- -般为MTTR (平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态\r\n  * 熔断关闭：熔断关闭不会对服务进行熔断\r\n  * 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常,关闭熔断\r\n\r\n* 断路器流程\r\n\r\n  * 断路器在什么情况下开始其作用\r\n    * 涉及到断路器的三个重要参数:快照时间窗、请求总数阀值、错误百分比阀值。\r\n      * 1:快照时间窗:断路器确定是否打开需要统计- 些请求和错误数据,而统计的时间范围就是快照时间窗,默认为最近的10秒。	\r\n      * 2:请求总数阀值:在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20, 意味着在10秒内,如果该hystrix命令的调用次数不足20次,即使所有的请求都超时或其他原因失败，断路器都不会打开。\r\n      * 3:错误百分比阀值:当请求总数在快照时间窗内超过了阀值,比如发生了30次调用，如果在这30次调用中,有15次发生了超时异常,也就是超过50%的错误百分比，在默认设定50%阀值情况下,这时候就会将断路器打开。\r\n  * 断路器开启或关闭的条件\r\n    * 满足一定的阈值（默认10s超过20请求次数）\r\n    * 当失败率达到一定的时候（默认10s内超过50%的失败请求）\r\n    * 到达以上阈值，断路器将会开启\r\n    * 当开启的时候，所有请求都不会进行转发\r\n    * 一段时间之后（默认是5s），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启，重复4和5\r\n  * 断路器打开之后\r\n    * 1:再有请求调用的时候，将不会调用主逻辑，而是直接调用降级allback。通过断路器,实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\r\n    * 2:原来的主逻辑要如何恢复呢?\r\n      对于这一-问题，hystrix也为我们实现了自动恢复功能。\r\n      当断路器打开,对主逻辑进行熔断之后，hystrix会启动一 个休眠时间窗,在这个时间窗内，降级逻辑是临时的成为主逻辑,\r\n      当休眠时间窗到期，断路器将进入半开状态,释放-次请求到原来的主逻辑上,如果此次请求正常返回，那么断路器将继续闭合,\r\n      主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态,休眠时间窗重新计时。\r\n  * All配置\r\n\r\n##### （8）服务限流 flowlimit\r\n\r\n* 后续的alibab的Sentinel说明\r\n\r\n##### （9）Hystrix Dashboard 实时监控\r\n\r\n* 除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dasghboard) , Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。\r\n* 使用：\r\n* pom\r\n\r\n```xml\r\n<!--新增hystrix dashboard-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml:只需要标明端口（9001）\r\n* 启动类：@EnableHystrixDashboard\r\n* 拿9001去监控微服务提供类（8001/8002/8003）\r\n* 监控\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'https://w.wallhaven.cc/full/73/wallhaven-73xore.jpg', '2', '1', '0', '2020-09-19 09:30:05', '2020-09-19 09:30:05');
INSERT INTO `blog` VALUES ('40', '服务网关Getway', 'SpringCloud', '转载', '<p>Spring Cloud Gateway的目标提供统- -的路由方式且基于 Filter 链的方式提供了网关基本的功能，例如:安全，监控/指标, 和限流。</p>\n', '## 服务网关\r\n\r\n### Getway新一代网关\r\n\r\n#### 1、概述简介\r\n\r\n##### （1）简介\r\n\r\n* SpringCloud Gateway是Spring Cloud的一个全新项目，纡Spring 5.0+ Spring Boot 2.0和Project Reactor等技术开发的网关,它旨在为微服务架构提供一种简单有效的统- 的API路由管理方式。\r\n* SpringCloud Gateway作为Spring Cloud生态系统中的网关,目标是替代Zuul,在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。\r\n* Spring Cloud Gateway的目标提供统- -的路由方式且基于 Filter 链的方式提供了网关基本的功能，例如:安全，监控/指标, 和限流。\r\n* 一句话：springCloud Geteway使用的Webflux中的reactor-netty响应式变成组建，底层使用了Netty通讯框架。\r\n\r\n##### （2）能干嘛\r\n\r\n* 反向代理\r\n* 鉴权\r\n* 流量控制\r\n* 熔断\r\n* 日志监控等\r\n\r\n##### （3）用在哪里?\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/gateway.png?Expires=1595326199&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=B%2FUDdPiObb26VQrNAW%2FB98TlZhw%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/gateway.png?Expires=1595326199&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=B%2FUDdPiObb26VQrNAW%2FB98TlZhw%3D)\r\n#### 2、三大核心概念\r\n\r\n##### （1）Route 路由\r\n\r\n* 构建网关的基本模块，它由ID,目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由\r\n\r\n##### （2）Predicate 断言\r\n\r\n* 参考的是Java8的java.util.function.Predicate 开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由\r\n\r\n##### （3）Filter 过滤\r\n\r\n* 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。\r\n\r\n##### （4）总体\r\n\r\n* web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。\r\n* predicate就是我们的匹配条件;\r\n* 而filter,就可以理解为一个无所不能的拦截器。有了这两个元素,再加上目标uri,就可以实现一个具体的路由了\r\n\r\n#### 3、Getway工作流程\r\n\r\n* 客户端向Spring Cloud Gatqway发出请求。然后在Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway\r\n* **Web Handler。**\r\n* Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\r\n* 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前( \"pre\" )或之后( \"post\" )执行业务逻辑。\r\n* Filter在 \"pre\" 类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等,\r\n* 在\"post\" 类型的过滤器中可以做响应内容、响应头的修改,日志的输出，流量监控等有着非常重要的作用。\r\n* 核心逻辑：路由转发+执行过滤链\r\n\r\n####  4、入门配置\r\n\r\n##### （1）pom\r\n\r\n```xml\r\n<!--新增gateway-->\r\n<dependency>\r\n   <groupId>org.springframework.cloud</groupId>\r\n   <artifactId>spring-cloud-starter-gateway</artifactId> </dependency>\r\n```\r\n\r\n##### （2）路由配置\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 9527\r\nspring:\r\n  application:\r\n    name: cloud-gateway\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          uri: http://localhost:8001   #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/get/**   #断言,路径相匹配的进行路由\r\n\r\n        - id: payment_routh2\r\n          uri: http://localhost:8001\r\n          predicates:\r\n            - Path=/payment/lb/**   #断言,路径相匹配的进行路由\r\n\r\neureka:\r\n  instance:\r\n    hostname: cloud-gateway-service\r\n  client:\r\n    service-url:\r\n      register-with-eureka: true\r\n      fetch-registry: true\r\n      defaultZone: http://eureka7001.com:7001/eureka\r\n```\r\n\r\n* bean\r\n\r\n```java\r\npackage com.rw.springcloud.config;\r\n\r\nimport org.springframework.cloud.gateway.route.RouteLocator;\r\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class GateWayConfig {\r\n    @Bean\r\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder){\r\n        RouteLocatorBuilder.Builder routes=routeLocatorBuilder.routes();\r\n        routes.route(\"path_rout_rw1\",\r\n                r->r.path(\"/guonei\")\r\n                        .uri(\"http://news.baidu.com/guonei\"))\r\n                .build();\r\n        return routes.build();\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### \r\n\r\n#### 5、通过微服务名实现动态路由\r\n\r\n* 默认情况下Gateway会根据注册中心注册的服务列表以注册中心上微服务名为路径创建**动态路由进行转发，从而实现动态路由的功能**\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 9527\r\nspring:\r\n  application:\r\n    name: cloud-gateway\r\n  cloud:\r\n    gateway:\r\n      discovery:\r\n        locator:\r\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\r\n      routes:\r\n        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n#          uri: http://localhost:8001   #匹配后提供服务的路由地址\r\n          uri: lb://cloud-payment-service\r\n          predicates:\r\n            - Path=/payment/get/**   #断言,路径相匹配的进行路由\r\n\r\n        - id: payment_routh2\r\n          #uri: http://localhost:8001\r\n          uri: lb://cloud-payment-service\r\n          predicates:\r\n            - Path=/payment/lb/**   #断言,路径相匹配的进行路由\r\n\r\n\r\neureka:\r\n  instance:\r\n    hostname: cloud-gateway-service\r\n  client:\r\n    service-url:\r\n      register-with-eureka: true\r\n      fetch-registry: true\r\n      defaultZone: http://eureka7001.com:7001/eureka\r\n```\r\n\r\n\r\n\r\n#### 6、Predicate的使用\r\n\r\n| 类型                      | 示例                                                         | 解释                                                   |\r\n| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------ |\r\n| 1.After Route Predicate   | - After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]         | 在XXX时间之后访问有效                                  |\r\n| 2.Before Route Predicate  | - Before=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]        | 在XXX时间之前访问有效                                  |\r\n| 3.Between Route Predicate | - Between=2020-03-08T10:59:34.102+08:00[Asia/Shanghai] ,  2020-03-08T10:59:34.102+08:00[Asia/Shanghai] | 在XXX时间之间访问有效                                  |\r\n| 4. Cookie Route Predicate | - Cookie=username,atguigu                                    | 带上Cookie访问并且Cookie 是username=zhangshuai才能访问 |\r\n| 5. Header Route Predicate | -Header=X-Request-Id, \\d+                                    | 请求头中要有X-Request-Id属性且值为整数的正则表达式     |\r\n| 6.Host Route Predicate    | - Host=**.atguigu.com                                        | 接收一组匹配的域名列表                                 |\r\n| 7.Method Route Predicate  | - Method=GET                                                 | 规定访问方法为GET                                      |\r\n| 8.Path Route Predicate    |                                                              |                                                        |\r\n| 9. Query Route Predicate  | - Query=username, \\d+                                        | 要有参数名称并且是正整数才能路由                       |\r\n\r\n\r\n\r\n#### 7、Filter的使用\r\n\r\n##### （1）是什么？\r\n\r\n* 路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应,路由过滤器只能指定路由进行使用。\r\n* Spring Cloud Gateway内置Y多种路由过滤器，他们都由GatewayFilter的工厂 类来产生\r\n\r\n##### （2）Spring Cloud Gateway的Filter\r\n\r\n* 生命周期，Only Two\r\n  * pre  请求之前\r\n  * post 请求之后\r\n* 种类，Only Two\r\n  * GatewayFilter 单一的\r\n  * GlobalFilter  全局的\r\n\r\n##### （3）自定义过滤器\r\n\r\n* 两个接口介绍\r\n  * GlobalFilter，Ordered\r\n* 功能\r\n  * 全局日志记录\r\n  * 统一网关鉴权\r\n* 案例代码\r\n\r\n```java\r\npackage com.rw.springcloud.filter;\r\n\r\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\r\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\r\nimport org.springframework.core.Ordered;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\nimport java.util.Date;\r\n\r\n@Component\r\npublic class MyLogGateWayFilter implements GlobalFilter, Ordered {\r\n    @Override\r\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\r\n        System.out.println(\"*********com in MyLogGateWayFilter\"+new Date());\r\n        String name=exchange.getRequest().getQueryParams().getFirst(\"uname\");\r\n        if(name==null){\r\n            System.out.println(\"******用户名为null，非法用户\");\r\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\r\n            return exchange.getResponse().setComplete();\r\n        }\r\n        return chain.filter(exchange);\r\n    }\r\n\r\n    @Override\r\n    public int getOrder() {\r\n        return 0;\r\n    }\r\n}\r\n\r\n```\r\n\r\n* 效果：请求地址中带由uname才让访问http://localhost:9527/payment/lb?uname=z3', 'https://w.wallhaven.cc/full/5w/wallhaven-5we2k7.png', '4', '1', '0', '2020-09-19 09:31:18', '2020-09-19 09:31:18');
INSERT INTO `blog` VALUES ('41', 'Spring Cloud Stream消息驱动', 'SpringCloud', '转载', '<p>Spring Cloud Stream为- -些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p>\n', '## 一、Spring Cloud Stream消息驱动\r\n\r\n### 1、为什么引入cloud Stream\r\n\r\n* MQ（消息中间件）\r\n  * ActiveMQ\r\n  * RabbitMQ\r\n  * RocketMQ\r\n  * Kafka\r\n\r\n* 问题：可能中间java开发用的RabbitMQ而数据分析用的Kafka\r\n  * 存在切换、维护、开发等问题\r\n* 针对上述问题有没有一种新技术诞生，让我们不再关注具体MQ的细节，我们只需要一种适配绑定的方式，自动给我们在各种MQ内切换\r\n* Cloud Stream应运而生，只需要操作Stream**屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型**\r\n\r\n### 2、什么是SpringCloud Stream\r\n\r\n* 官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。\r\n* 应用程序通过inputs或者outputs与Spring Cloud Stream中binder对象交互。通过我们配置来binding(绑定)，而Spring Cloud Stream的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以防便使用消息驱动的方式。\r\n* 通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream为- -些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。\r\n* 目前仅支持RabbitMQ、Kafka.\r\n\r\n### 3、Spring Cloud Stream标准流程套路\r\n\r\n* Binder：很方便的链接中间件，屏蔽差异\r\n* Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置\r\n* Source和Sink：简单的可理解为参照对象是SpringCloud Stream自身，从Stream发布消息就是输出，接收消息就是输入。\r\n\r\n\r\n\r\n| 组成            | 说明                                                         |\r\n| --------------- | ------------------------------------------------------------ |\r\n| Middleware      | 中间件，目前只支持RabbitMQ和Kafka                            |\r\n| Binder          | Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder,通过<br/>Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,<br/>RabbitMQ的exchange),这些都可以通过配置文件来实现 |\r\n| @Input          | 注解标识输入通道，通过该输入通道接收到的消息进入应用程序     |\r\n| @Output         | 注解标识输出通道，发布的消息将通过该通道离开应用程序         |\r\n| @StreamListener | 监听队列，用于消费者的队列的消息接收                         |\r\n| @EnableBinding  | 指信道channel和exchange绑定在-起                             |\r\n\r\n### 4、案例\r\n\r\n#### （1）消息驱动之生产者\r\n\r\n* pom\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 8801\r\n\r\nspring:\r\n  application:\r\n    name: cloud-stream-provider\r\n  cloud:\r\n    stream:\r\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\r\n        defaultRabbit: # 表示定义的名称，用于于binding整合\r\n          type: rabbit # 消息组件类型\r\n          environment: # 设置rabbitmq的相关的环境配置\r\n            spring:\r\n              rabbitmq:\r\n                host: localhost\r\n                port: 5672\r\n                username: guest\r\n                password: guest\r\n      bindings: # 服务的整合处理\r\n        output: # 这个名字是一个通道的名称\r\n          destination: studyExchange # 表示要使用的Exchange名称定义\r\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\r\n          binder: defaultRabbit  # 设置要绑定的消息服务的具体设置\r\n\r\neureka:\r\n  client: # 客户端进行Eureka注册的配置\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n  instance:\r\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\r\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\r\n    instance-id: send-8801.com  # 在信息列表时显示主机名称\r\n    prefer-ip-address: true     # 访问的路径变为IP地址\r\n```\r\n\r\n* service\r\n\r\n```java\r\npackage com.rw.springcloud.service.impl;\r\n\r\nimport com.rw.springcloud.service.IMessageProvider;\r\nimport org.springframework.cloud.stream.annotation.EnableBinding;\r\nimport org.springframework.cloud.stream.messaging.Source;\r\nimport org.springframework.integration.support.MessageBuilder;\r\nimport org.springframework.messaging.MessageChannel;\r\n\r\nimport javax.annotation.Resource;\r\nimport java.util.UUID;\r\n\r\n@EnableBinding(Source.class) //定义消息的同送管道\r\npublic class MessageProviderImpl implements IMessageProvider {\r\n    @Resource\r\n    private MessageChannel output; //消息发送管道\r\n    @Override\r\n    public String send() {\r\n        String serial= UUID.randomUUID().toString();\r\n        output.send(MessageBuilder.withPayload(serial).build());\r\n        System.out.println(\"*******serial:\"+serial);\r\n        return serial;\r\n    }\r\n}\r\n```\r\n\r\n* controller\r\n\r\n```java\r\npackage com.rw.springcloud.controller;\r\n\r\nimport com.rw.springcloud.service.IMessageProvider;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport javax.annotation.Resource;\r\n\r\n@RestController\r\npublic class SendMessageController {\r\n    @Resource\r\n    private IMessageProvider messageProvider;\r\n    @GetMapping(\"/sendMessage\")\r\n    public String sendMessage(){\r\n        return  messageProvider.send();\r\n    }\r\n}\r\n```\r\n\r\n#### （2）消息驱动之消费者\r\n\r\n* pom\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 8802\r\n\r\nspring:\r\n  application:\r\n    name: cloud-stream-consumer\r\n  cloud:\r\n    stream:\r\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\r\n        defaultRabbit: # 表示定义的名称，用于于binding整合\r\n          type: rabbit # 消息组件类型\r\n          environment: # 设置rabbitmq的相关的环境配置\r\n            spring:\r\n              rabbitmq:\r\n                host: localhost\r\n                port: 5672\r\n                username: guest\r\n                password: guest\r\n      bindings: # 服务的整合处理\r\n        input: # 这个名字是一个通道的名称\r\n          destination: studyExchange # 表示要使用的Exchange名称定义\r\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\r\n          binder: defaultRabbit  # 设置要绑定的消息服务的具体设置\r\n\r\neureka:\r\n  client: # 客户端进行Eureka注册的配置\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n  instance:\r\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\r\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\r\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\r\n    prefer-ip-address: true     # 访问的路径变为IP地址\r\n```\r\n\r\n* controller\r\n\r\n```java\r\npackage com.rw.springcloud.controller;\r\n\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.cloud.stream.annotation.EnableBinding;\r\nimport org.springframework.cloud.stream.annotation.StreamListener;\r\nimport org.springframework.cloud.stream.messaging.Sink;\r\nimport org.springframework.messaging.Message;\r\nimport org.springframework.stereotype.Component;\r\n\r\n\r\n@Component\r\n@EnableBinding(Sink.class)\r\npublic class ReceiveMessageListenerController {\r\n    @Value(\"${server.port}\")\r\n    private String serverPort;\r\n    @StreamListener(Sink.INPUT)\r\n    private void  input(Message<String> message){\r\n        System.out.println(\"消费者1号----->接收消息\"+message.getPayload()+\"\\t port:\"+serverPort);\r\n    }\r\n}\r\n```\r\n\r\n### 5、分组消费与持久化\r\n\r\n#### （1）消费\r\n\r\n* 问题：比如在如下场景中，订单系统我们做集群部署,都会从RabbitMQ中获取订单信息,那如果一个订单同时被两个服务获取到，那么就会造成数据错误,我们得避免这种情况。这时我们就可以使用Stream中的消息分组来解决\r\n* 注意在Stream中处于同一个group中的多个消费者是竞争关系,就能够保证消息只会被其中一个应用消费- -次。\r\n* **不同组是可以全面消费的(重复消费),**\r\n* **同一组内会发生竞争关系，只有其中一个可以消费。**\r\n* 故障原因：重复消费\r\n* 导致原因：默认分组group是不同的，组流水号不一样，被认为不同组，可以消费\r\n* 解决：自定义分组\r\n  * 原理：微服务应用放置于同- -个group中，就能够保证消息只会被其中一一个应用消费一次。不同的组是可以消费的，同一一个组内会发生竞争关系，只有其中一个可以消费。\r\n  * yml binder下边对齐添加：group: rwA\r\n  * 把相同的集群服务都设置到一个组，就会产生竞争关系，轮询获取\r\n\r\n#### （2）持久化\r\n\r\n* 添加group 的如果服务宕机之后 重启不会丢失消息 会重新读取并消费 nice\r\n\r\n------\r\n\r\n\r\n\r\n## 二、SpringCloud Sleuth 分布式请求链路跟踪\r\n\r\n### 1、概述\r\n\r\n#### （1）为什么出现？\r\n\r\n* 在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果,每个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引|起整个请求最后的失败。\r\n\r\n#### （2）是什么？\r\n\r\n* Spring Cloud Sleuth提供了一套完整的跟踪的解决方案\r\n* 在分布式系统中提供追踪解决方案并且兼容支持了zipkin\r\n\r\n### 2、搭建链路监控步骤\r\n\r\n#### （1）zipkin\r\n\r\n* 下载\r\n  * SpringCloud从F版起已不需要自己构建ZipkinServer了，只需调用jar包即可\r\n  * https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/\r\n* 运行jar\r\n  * java -jar \r\n  * http://localhost:9411/zipkin/\r\n* 运行控制台\r\n* 名词解释\r\n  * Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识\r\n  * span:表示调用链路来源，通俗的理解span就是一次请求信息\r\n\r\n#### （2）服务提供者\r\n\r\n* pom\r\n\r\n```xml\r\n<!--包含了sleuth+zipkin-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 80\r\n\r\nspring:\r\n  application:\r\n    name: cloud-order-service\r\n  zipkin:\r\n    base-url: http://localhost:9411\r\n  sleuth:\r\n    sampler:\r\n      probability: 1\r\neureka:\r\n  client:\r\n    #表示是否将自己注册斤EurekaServer默认为true\r\n    register-with-eureka: true\r\n    # 是否从EurekaServer抓取以有的注册信息，默认为true。系欸但无所谓，集群必须设置为true才能配合ribbon使用负载均衡\r\n    fetchRegistry: true\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n      #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\r\n  instance:\r\n    instance-id: order80\r\n    prefer-ip-address: true\r\n```\r\n\r\n#### （3）服务消费者（调用方）\r\n\r\n#### （4）一次启动eureka7001/8001/80\r\n\r\n#### （5）打开浏览器访问：http://localhost:9411\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/stream.png?Expires=1595326760&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=F88VGG3dI%2Fk6SxOI8i5dfoo%2BZZk%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/stream.png?Expires=1595326760&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=F88VGG3dI%2Fk6SxOI8i5dfoo%2BZZk%3D)\r\n\r\n\r\n\r\n\r\n\r\n', 'https://w.wallhaven.cc/full/39/wallhaven-39m7vd.jpg', '19', '1', '0', '2020-09-19 09:32:15', '2020-09-19 09:32:15');
INSERT INTO `blog` VALUES ('42', 'SpringCloud Alibaba', 'springcloud', '转载', '<p>服务限流降级、服务注册与发现、分布式配置管理、消息驱动能力、阿里云对象存储、分布式任务调度、格任务支持海量子任务均匀分配到所有Worker (schedulerx-client). 上执行。</p>\r\n \r\n \r\n \r\n \r\n ', '## SpringCloud Alibaba\r\n\r\n### 1、能干嘛？\r\n\r\n* 服务限流降级:默认支持Servlet、Feign、 RestTemplate、 Dubbo 和RocketMQ限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics监控。\r\n* 服务注册与发现:适配Spring Cloud服务注册与发现标准,默认集成了Ribbon的支持。\r\n* 分布式配置管理:支持分布式系统中的外部化配置,配置更改时自动刷新。\r\n* 消息驱动能力:基于Spring Cloud Stream为微服务应用构建消息驱动能力。\r\n* 阿里云对象存储:阿里云提供的海量、安全、低成本、舸靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。\r\n* 分布式任务调度:提供秒级、精准、舸靠、可用的定时(基于Cron表达式)任务调度服务。同时提供分布式的任务执行模型,如网格任务。网\r\n* 格任务支持海量子任务均匀分配到所有Worker (schedulerx-client). 上执行。\r\n\r\n### 2、 去哪下？\r\n\r\n* https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md\r\n\r\n### 3、怎么玩？\r\n\r\n* Sentinel\r\n  * 阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\r\n* Nacos\r\n  * 阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\r\n* RocketMQ\r\n  * Apache RocketMQM基于Java的高性能、高吞吐量的分布式消息和流计算平台。\r\n* Dubbo\r\n  * Apache DubboM是-款高性能Java RPC框架。\r\n* Seata\r\n  * 阿里巴巴开源产品，-个易于使用的高性能微服务分布式事务解决方案.\r\n* Alibaba Cloud OSS\r\n  * 阿里云对象存储服务(Object Storage Service,简称OSS)， 是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\r\n* Alibaba Cloud SchedulerX\r\n  * 阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务.\r\n\r\n### 4、Nacos\r\n\r\n#### （1）是什么？\r\n\r\n* Nacos=Eureka+Config+Bus\r\n\r\n#### （2）能干嘛？\r\n\r\n* 替代Eureka做服务注册中心\r\n* 替代Config做服务配置中心\r\n\r\n#### （3）Nacos安装运行\r\n\r\n* 下载地址：https://github.com/alibaba/nacos/releases/tag/1.1.4\r\n* 下载解压后直接进入bin目录运行start.cmd\r\n\r\n#### （3）Nacos作为服务注册中心演示\r\n\r\n##### 微服务提供者\r\n\r\n* pom\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 9002\r\n\r\nspring:\r\n  application:\r\n    name: nacos-payment-provider\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #配置Nacos地址\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n* 主启动类\r\n\r\n```java\r\npackage com.rw.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\r\n\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class PaymentMain9002 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(PaymentMain9002.class,args);\r\n    }\r\n}\r\n```\r\n\r\n##### 微服务消费者\r\n\r\n* pom\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 83\r\n\r\nspring:\r\n  application:\r\n    name: nacos-order-consumer\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848\r\n\r\n\r\nservice-url:\r\n  nacos-user-service: http://nacos-payment-provider\r\n```\r\n\r\n* config\r\n\r\n```java\r\npackage com.rw.springcloud.config;\r\n\r\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.client.RestTemplate;\r\n\r\n\r\n@Configuration\r\npublic class ApplicationContextConfig\r\n{\r\n    @Bean\r\n    @LoadBalanced\r\n    public RestTemplate getRestTemplate()\r\n    {\r\n        return new RestTemplate();\r\n    }\r\n}\r\n```\r\n\r\n* controller\r\n\r\n```java\r\npackage com.rw.springcloud.controller;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.client.RestTemplate;\r\n\r\nimport javax.annotation.Resource;\r\n\r\n@RestController\r\n@Slf4j\r\npublic class OrderNacosController {\r\n    @Resource\r\n    private RestTemplate restTemplate;\r\n\r\n    @Value(\"${service-url.nacos-user-service}\")\r\n    private  String serverURL;\r\n    @GetMapping(\"/consumer/payment/nacos/{id}\")\r\n    public String PaymentInfo(@PathVariable(\"id\") Long id){\r\n        return restTemplate.getForObject(serverURL+\"/payment/nacos/\"+id,String.class);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n##### Nacos与其他注册中心相比较\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba.png?Expires=1595326956&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=VfNl%2BHTeXTQs25SFvlhIvq%2BDdP8%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba.png?Expires=1595326956&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=VfNl%2BHTeXTQs25SFvlhIvq%2BDdP8%3D)\r\n\r\n* C是所有节点在同一时间看到的数据是一致的; 而A的定义是所有的请求都会收到响应。\r\n* 何时选择使用何种模式?\r\n  * 一般来说,\r\n  * 如果不需要存储服务级别的信息且服务实例是通过nacos- client注册，并能够保持心跳上报,那么就可以选择AP模式。当前主流的服务如Spring cloud和Dubbo服务,都适用于AP模式，AP模式为了服务的可能性而减弱了一致性， 因此AP模式下只支持注册临时实例。\r\n  * 如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实例，此时则是以Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务,如果服务不存在,则会返回错误。\r\n  * curl -X PUT \'$NACOS_ SERVER:8848/nacos/v1/ns/operator/switches?entry= serverMode&value=CP\'\r\n\r\n#### （3）Nacos作为服务配置中心演示\r\n\r\n* pom\r\n\r\n```xml\r\n  <!--nacos-config-->\r\n        <dependency>\r\n            <groupId>com.alibaba.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\r\n        </dependency>\r\n        <!--nacos-discovery-->\r\n        <dependency>\r\n            <groupId>com.alibaba.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n        </dependency>\r\n```\r\n\r\n* bootstrop.yml\r\n\r\n```properties\r\nserver:\r\n  port: 3377\r\n\r\nspring:\r\n  application:\r\n    name: nacos-config-client\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #服务注册中心地址\r\n      config:\r\n        server-addr: localhost:8848 #配置中心地址\r\n        file-extension: yaml #指定yaml格式的配置\r\n```\r\n\r\n* application.yml\r\n\r\n```properties\r\nspring:\r\n  profiles:\r\n    active: dev\r\n```\r\n\r\n* 主启动类\r\n\r\n```java\r\npackage com.rw.springcloud;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\r\n@EnableDiscoveryClient\r\n@SpringBootApplication\r\npublic class NacosConfigClientMain3377\r\n{\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(NacosConfigClientMain3377.class, args);\r\n    }\r\n}\r\n```\r\n\r\n* controller\r\n\r\n```java\r\npackage com.rw.springcloud.controller;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n@RestController\r\n@RefreshScope //支持Nacos的动态刷新功能\r\npublic class ControllerClientController {\r\n    @Value(\"${config.info}\")\r\n    private String configInfo;\r\n\r\n    @GetMapping(\"/config/info\")\r\n    public String getConfigInfo() {\r\n        return configInfo;\r\n    }\r\n}\r\n```\r\n\r\n* nacos自带动态刷新功能\r\n* Nacos作为配置中心-分类配置\r\n  * yml中加group 实现分组\r\n  * yml中加namespace实现命名空间切换\r\n\r\n#### （3）Nacos集群和持久化配置（重要）\r\n\r\n* 默认Nacos使用嵌入式数据库实现数据的存储。所以,如果启动多个默认配置下的Nacos节点,数据存储是存在- 致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署,目前只支持MySQL的存储。\r\n* Nacos默认自带的是嵌入式数据库derby，但是如果搭建集群的话每个nacos都带有一个自己的数据库保证不了数据的一致性，所以需要统一的配置mysql数据库来做数据统一\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba1.png?Expires=1595326993&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=ih8gPwhIdDIb0tUaI%2F8tTQ1tzZI%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba1.png?Expires=1595326993&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=ih8gPwhIdDIb0tUaI%2F8tTQ1tzZI%3D)\r\n### 5、Sentinel\r\n\r\n* 单独一个组件，可以独立出来\r\n* 支持节目安华的细粒度统一配置\r\n\r\n#### （1）Sentinel安装\r\n\r\n* 下载地址：https://github.com/alibaba/Sentinel/releases\r\n* java -jar 运行就可\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba2.png?Expires=1595327066&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=0AkI9eWy%2BSErsyVpYp5OIeDn6CA%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba2.png?Expires=1595327066&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=0AkI9eWy%2BSErsyVpYp5OIeDn6CA%3D)\r\n\r\n#### （2）Sentinel核心\r\n\r\n* Sentinel分为两个部分:\r\n  * 核心库(Java客户端)不依赖任何框架/库，能够运行于所有Java运行时环境，同时对Dubbo /Spring Cloud等框架也有较好的支持。\r\n  * 控制台(Dashboard) 基于Spring Boot开发,打包后可以直接运行，不需要额外的Tomcat等应用容器。\r\n\r\n#### （3）Sentinel安装\r\n\r\n#### （4）Sentinel使用\r\n\r\n* pom\r\n\r\n```xml\r\n<dependency>\r\n        <groupId>com.alibaba.csp</groupId>\r\n        <artifactId>sentinel-datasource-nacos</artifactId>\r\n    </dependency>\r\n\r\n    <dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\r\n</dependency>\r\n\r\n    <dependency>\r\n        <groupId>org.springframework.cloud</groupId>\r\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n    </dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 8401\r\n\r\nspring:\r\n  application:\r\n    name: cloudalibaba-sentinel-service\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848\r\n    sentinel:\r\n      transport:\r\n        dashboard: localhost:8080\r\n        port: 8719  #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n#### （5）Sentinel流控规则\r\n\r\n* 资源名:唯一名称，默认请求路径\r\n* 针对来源: Sentinel可以针对调用者进行限流，填写微服务名，默认default (不区分来源)\r\n* 阈值类型/单机阈值:\r\n* QPS (每秒钟的请求数量) :当调用该api的QPS达到阈值的时候，进行限流\r\n  * 线程数:当调用该api的线程数达到阈值的时候，进行限流\r\n* 是否集群:不需要集群\r\n* 流控模式:\r\n  * 直接: api达到限流条件时，直接限流\r\n  * 关联:当关联的资源达到阈值时,就限流自己\r\n  * 链路:只记录指定链路上的流量(指定资源从入口资源进来的流量, 如果达到阈值，就进行限流) [api级别的针对来源]\r\n* 流控效果:\r\n  * 快速失败:直接失败,抛异常\r\n  * Warm Up:根据codeFactor (冷加载因子,默认3)的值,从阈值/codeFactor, 经过预热时长,才达到设置的QPS阈值\r\n  * 排队等待:匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS,否则无效\r\n\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba3.png?Expires=1595327100&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=LAdQe11F5nZ98OhJFlBfXBfEIMc%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba3.png?Expires=1595327100&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=LAdQe11F5nZ98OhJFlBfXBfEIMc%3D)\r\n\r\n* 直接失败\r\n* 关联：eg：订单处理不过来 挂掉下订单服务\r\n* WarmUp预热\r\n* 刚开始是阈值/3 经过预热时间后达到阈值\r\n  * eg：秒杀系统开启瞬间，回有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来，慢慢的把阈值增长到设置的阈值\r\n* 排对等待：高并发进来之后排对，挨个等待，只能是QPS\r\n\r\n* 自己写兜底方法\r\n\r\n#### （6）Sentinel降级规则\r\n\r\n* RT (平均响应时间,秒级)\r\n  * 平均响应时间超出阈值且在时间窗口内通过的请求>=5, 两个条件同时满足后触发降级\r\n  * 窗口期过后关闭断路器\r\n  * RT最大4900 (更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才 能生效)\r\n* Sentinel没有半开状态 跳闸之后默认行为抛出：DegradeException\r\n* **默认1s中请求数>5 且请求时间都>设定阈值的话在未来设置的 关闭窗口时间内会跳闸无法访问**\r\n* 异常比例\r\n  * 1s中请求数>5 且 异常比例大于设定的异常比例也会开启\r\n* 异常数\r\n  * 当资源近1分钟的异常数目超过阈值之后会进行熔断\r\n\r\n#### （7）Sentinel热点key限流（重要）\r\n\r\n* 何为热点?热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的Top K数据，并对其访问进行限制。比如:\r\n  * 商品ID为参数,统计一段时间内最常购买的商品ID并进行限制\r\n  * 用户ID为参数，针对一段时间内频繁访问的用户ID进行限制\r\n* 配置\r\n\r\n```java\r\n@GetMapping(\"/testHotKey\")\r\n@SentinelResource(value = \"testHotKey\",blockHandler = \"deal_testHotKey\")\r\npublic String testHotKey(@RequestParam(value = \"p1\", required = false) String p1,\r\n                         @RequestParam(value = \"p2\", required = false) String p2) {\r\n    return \"testHotKey\";\r\n}\r\npublic String deal_testHotKey(String p1, String p2, BlockException exception){\r\n    return \"------deal_testHotKey,哭哭\";\r\n}\r\n```\r\n\r\n* 参数例外项：\r\n  * 我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样（开小灶）\r\n* 如果出现异常的话不会给你兜底，配置类出错会兜底\r\n* 总结\r\n  @SentinelResource主管配置出错，运行出错该走异常走异常\r\n\r\n#### （8）Sentinel系统规则\r\n\r\n* Sentinel系统自适应限流从整体维度对应用入口流量进行控制，结合应用的Load、CPU 使用率、总体平均RT、入口QPS和并发线程数等几个维度的监控指标,通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\r\n\r\n  \r\n\r\n#### （9）SentinelResource\r\n\r\n* 按 URL地址限流\r\n* 按资源名限流\r\n* 以上会出现问题：\r\n  * 1、系统默认的, 没有体现我们自己的业务要求。\r\n  * 2、依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。\r\n  * 3、每个业务方法都添加一个兜底的，那代码膨胀加剧。\r\n  * 4、全局统一的处理方法没有体现。\r\n\r\n* 客户自定义的限流处理逻辑\r\n\r\n  * 自定义限流处理类\r\n\r\n  ```java\r\n  package com.rw.springcloud.alibaba.myhandler;\r\n  \r\n  import com.alibaba.csp.sentinel.slots.block.BlockException;\r\n  import com.atguigu.springcloud.entities.*;\r\n  \r\n  public class CustomerBlockHandler {\r\n  \r\n      public static CommonResult handleException(BlockException exception) {\r\n          return new CommonResult(2020, \"自定义限流处理信息....CustomerBlockHandler\");\r\n  \r\n      }\r\n      public static CommonResult handleException2(BlockException exception) {\r\n          return new CommonResult(2020, \"自定义限流处理信息....CustomerBlockHandler2\");\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n  * 修改controller\r\n\r\n  ```java\r\n  @GetMapping(\"/rateLimit/customerBlockHandler\")\r\n  @SentinelResource(value = \"customerBlockHandler\",\r\n          blockHandlerClass = CustomerBlockHandler.class,  // 哪个类\r\n          blockHandler = \"handlerException2\")  // 类中的哪个方法\r\n  public CommonResult customerBlockHandler()\r\n  {\r\n      return new CommonResult(200,\"按客戶自定义\",new Payment(2020L,\"serial003\"));\r\n  }\r\n  ```\r\n\r\n#### （10）服务熔断功能\r\n\r\n* fallback 异常处理兜底方法：管java异常\r\n* blockHandler：只管sentinel降级\r\n* 若blockHandler和fallback都进行了配置,则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。\r\n* 可结合rest ribbon\r\n* 可结合 openFeign\r\n\r\n#### （11）规则持久化\r\n\r\n* 问题：之前是重启后限流规则就没了\r\n* pom\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.alibaba.csp</groupId>\r\n    <artifactId>sentinel-datasource-nacos</artifactId>\r\n</dependency>\r\n```\r\n\r\n* yml\r\n\r\n```properties\r\nserver:\r\n  port: 8401\r\n\r\nspring:\r\n  application:\r\n    name: cloudalibaba-sentinel-service\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #Nacos服务注册中心地址\r\n    sentinel:\r\n      transport:\r\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\r\n        port: 8719\r\n      datasource:\r\n        ds1:\r\n          nacos:\r\n            server-addr: localhost:8848\r\n            dataId: cloudalibaba-sentinel-service\r\n            groupId: DEFAULT_GROUP\r\n            data-type: json\r\n            rule-type: flow\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n\r\nfeign:\r\n  sentinel:\r\n    enabled: true # 激活Sentinel对Feign的支持\r\n```\r\n\r\n* 添加nacos内容解析\r\n[![](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba4.png?Expires=1595327144&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=zwS5G%2FNEtQChaoLbNJfnP2WyAHM%3D)](http://rw-blog.oss-cn-beijing.aliyuncs.com/springcloud/alibaba4.png?Expires=1595327144&OSSAccessKeyId=TMP.3Kgc87sv3Aj38F3p3rNzt5MaUP6q7gHEe12X9o69ZPu2KDHiiWAZC4QdjkharV5H3J3Hx5mpFhkUwvXyCDj6SX7UmmhKfQ&Signature=zwS5G%2FNEtQChaoLbNJfnP2WyAHM%3D)\r\n\r\n### 6、SpringCloud Alibaba Seata处理分布式事务\r\n\r\n* 一次业务 操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题\r\n\r\n#### （1）Seata简介\r\n\r\n* 1+3：Transaction ID XID 全局唯一的事务ID\r\n* 三组件概念：\r\n  * Transaction Coordinator (TC-事务协调者)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚\r\n  * Transaction Manager (TM-事务管理器)：控制全局事务的边界，负责开启一一个全局事务，并最终发起全局提交或全局回滚的决议;\r\n  * Resource Manager (RM-资源管理器)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支(本地)事务的提交和回滚\r\n\r\n* 处理过程\r\n  * TM向TC申请开启一个全局事務，全局事务创建成功并生成一 个全局唯一 的XID;\r\n  * XID 在微服务调用链路的上下文中传播;\r\n  * RM向TC注册分支事务,将其纳入XID对应全局事务的管辖;\r\n  * TM向TC发起针对XID的全局提交或回滚决议;\r\n  * TC调度XID下管辖的全部分支事务完成提交或回滚请求。\r\n\r\n#### （2）Seata-Server安装下载\r\n\r\n* https://github.com/seata/seata/releases\r\n* 需要配置信息注册到nacos还有本地数据库链接\r\n\r\n#### （3）怎么玩？\r\n\r\n* 非常简单\r\n* 本地@Transactional\r\n* 全局@GlobalTransactional', 'https://w.wallhaven.cc/full/ym/wallhaven-ym1zx7.png', '3', '1', '0', '2020-09-19 09:33:47', '2020-09-19 09:33:47');
INSERT INTO `blog` VALUES ('47', 'Springboot集成Redis', 'springboot', '转载', '<p>Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。</p>\r\n', '## 一、Redis介绍\r\n\r\nRedis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。\r\n\r\n### Redis的特点：\r\n\r\n1，Redis读取的速度是110000次/s，写的速度是81000次/s；\r\n\r\n2，原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\r\n\r\n3，支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)\r\n\r\n4，持久化，集群部署\r\n\r\n5，支持过期时间，支持事务，消息订阅\r\n## 二、项目集成Redis\r\n### 1、添加依赖\r\n```xml\r\n<!-- redis -->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-data-redis</artifactId>\r\n</dependency>\r\n\r\n<!-- spring2.X集成redis所需common-pool2-->\r\n<dependency>\r\n    <groupId>org.apache.commons</groupId>\r\n    <artifactId>commons-pool2</artifactId>\r\n    <version>2.6.0</version>\r\n</dependency>\r\n```\r\n### 2、添加redis配置类\r\n```java\r\n@EnableCaching\r\n@Configuration\r\npublic class RedisConfig extends CachingConfigurerSupport {\r\n\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\r\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\r\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\r\n        ObjectMapper om = new ObjectMapper();\r\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\r\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\r\n        jackson2JsonRedisSerializer.setObjectMapper(om);\r\n        template.setConnectionFactory(factory);\r\n        //key序列化方式\r\n        template.setKeySerializer(redisSerializer);\r\n        //value序列化\r\n        template.setValueSerializer(jackson2JsonRedisSerializer);\r\n        //value hashmap序列化\r\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\r\n        return template;\r\n    }\r\n\r\n    @Bean\r\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\r\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\r\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\r\n        //解决查询缓存转换异常的问题\r\n        ObjectMapper om = new ObjectMapper();\r\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\r\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\r\n        jackson2JsonRedisSerializer.setObjectMapper(om);\r\n        // 配置序列化（解决乱码的问题）,过期时间600秒\r\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\r\n                .entryTtl(Duration.ofSeconds(600))\r\n              .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))\r\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\r\n                .disableCachingNullValues();\r\n        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)\r\n                .cacheDefaults(config)\r\n                .build();\r\n        return cacheManager;\r\n    }\r\n}\r\n```\r\n## 3、在接口中添加redis缓存\r\n### 3.1 Spring Boot缓存注解\r\n* 缓存@Cacheable\r\n根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。\r\n\r\n查看源码，属性值如下：\r\n\r\n| 属性/方法  | 解释  |\r\n| ------------ | ------------ |\r\n| value  | 缓存名，必填，它指定了你的缓存存放在哪块命名空间  |\r\n|  cacheNames | 与 value 差不多，二选一即可  |\r\n|  key | 可选属性，可以使用 SpEL 标签自定义缓存的key  |\r\n\r\n* 缓存@CachePut\r\n使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。\r\n\r\n查看源码，属性值如下：\r\n\r\n| 属性/方法  | 解释  |\r\n| ------------ | ------------ |\r\n| value  | 缓存名，必填，它指定了你的缓存存放在哪块命名空间  |\r\n|  cacheNames | 与 value 差不多，二选一即可  |\r\n|  key | 可选属性，可以使用 SpEL 标签自定义缓存的key  |\r\n\r\n* 缓存@CacheEvict\r\n使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上\r\n\r\n查看源码，属性值如下：\r\n\r\n| 属性/方法  | 解释  |\r\n| ------------ | ------------ |\r\n| value  | 缓存名，必填，它指定了你的缓存存放在哪块命名空间  |\r\n|  cacheNames | 与 value 差不多，二选一即可  |\r\n|  key | 可选属性，可以使用 SpEL 标签自定义缓存的key  |\r\n|  allEntries | 是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存  |\r\n|  beforeInvocation | 是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存  |\r\n\r\n### 3.2启动redis服务\r\n### 3.3连接redis服务可能遇到的问题\r\n（1）关闭liunx防火墙\r\n\r\n（2）找到redis配置文件， 注释一行配置 注释掉：#bind 127.0.0.1\r\n\r\n### 3.4添加redis配置\r\n\r\n```xml\r\nspring.redis.host=192.168.44.132\r\nspring.redis.port=6379\r\nspring.redis.database= 0\r\nspring.redis.timeout=1800000\r\n\r\nspring.redis.lettuce.pool.max-active=20\r\nspring.redis.lettuce.pool.max-wait=-1\r\n#最大阻塞等待时间(负数表示没限制)\r\nspring.redis.lettuce.pool.max-idle=5\r\nspring.redis.lettuce.pool.min-idle=0\r\n```\r\n### 3.5 在方法上添加注解\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n------作者：Ruiwen丶Wang', 'https://w.wallhaven.cc/full/nr/wallhaven-nrj25w.jpg', '2', '1', '0', '2020-09-19 11:00:09', '2020-09-19 11:00:09');
INSERT INTO `blog` VALUES ('48', 'Linux中安装zookeeper', 'Linux', '转载', '环境：\n>1.VMware® Workstation 12 Pro  \n>2.CentOS7  \n>3.zookeeper-3.4.10(本文写作时的最新稳定版)  ', '最近打算出一个系列，介绍Dubbo的使用。\n\n---\n分布式应用现在已经越来越广泛，Spring Could也是一个不错的一站式解决方案，不过据我了解国内目前貌似使用阿里Dubbo的公司比较多，一方面这个框架也确实很OK，另一方面可能也是因为Dubbo的中文文档比较全的缘故，据Dubbo官网上的消息，阿里已经重新开始了对Dubbo的维护，这也算是使用Dubbo的互联网公司的福音了吧。OK，废话不多说，今天我们就先来看看如何在Linux上安装zookeeper。\n\n---\n\n了解过Dubbo的小伙伴都知道，Dubbo官方建议我们使用的注册中心就是zookeeper，zookeeper本来是Hadoop的一个子项目，现在发展成了Apache的顶级项目，看名字就知道Zookeeper就是动物园管理员，管理Hadoop(大象)、Hive(蜂房/蜜蜂)等动物。Apache上的Zookeeper分Linux版和Windows版，但是考虑到实际生产环境都是Linux，所以我们这里主要介绍Linux上Zookeeper的安装，Windows上Zookeeper的安装则比较简单，下载解压即可，和Tomcat差不多。\n\nOK，废话不多说，接下来我们就来看看zookeeper的安装步骤。\n\n---\n环境：\n>1.VMware® Workstation 12 Pro  \n>2.CentOS7  \n>3.zookeeper-3.4.10(本文写作时的最新稳定版)  \n\n---\n# 安装步骤\n1.下载zookeeper\n\nzookeeper下载地址如下，小伙伴们可以在第一个地址中选择适合自己的zookeeper版本，也可以直接点击第二个地址下载我们本文使用的zookeeper。\n\n>1.[http://mirrors.hust.edu.cn/apache/zookeeper/](http://mirrors.hust.edu.cn/apache/zookeeper/)  \n\n>2.[http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz](http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz)\n\n\n\n2.将下载好的zookeeper上传到Linux服务器上\n\n上传方式多种多样，我这里采用了xftp，小伙伴们也可以直接使用putty上传，上传结果如下：\n![这里写图片描述](http://img.blog.csdn.net/20170825114622362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n3.将文件解压到/opt目录下  \n\n![这里写图片描述](http://img.blog.csdn.net/20170825115122378?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4.进入到刚刚解压好的目录中，创建两个文件夹，分别是data和logs，如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115324970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n5.将解压后zookeeper-3.4.10文件夹下的zoo_sample.cfg文件拷贝一份命名为zoo.cfg，如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115426251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n6.修改zoo.cfg文件，添加data和log目录，如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115527367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n>1.2888 端口号是zookeeper服务之间通信的端口   \n>2.3888 是zookeeper 与其他应用程序通信的端口  \n>3.initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒。  \n>4.syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒  \n>5.server.A=B:C:D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的IP地址或/etc/hosts文件中映射了IP的主机名；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。\n\n7.在 dataDir=/opt/zookeeper-3.4.10/data下创建 myid文件 编辑myid文件，并在对应的IP的机器上输入对应的编号。如在zookeeper上，myid文件内容就是1。如果只在单点上进行安装配置，那么只有一个server.1。如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115647920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n8.在.bash_profile文件中增加zookeeper配置：\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115729473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n9.使配置生效\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115807787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n10.关闭防火墙\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115848488?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n11.启动并测试\n\n![这里写图片描述](http://img.blog.csdn.net/20170825115938795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n>启动之后如果能看到Mode:standalone就表示启动成功了。\n\n12.关闭zookeeper\n\n![这里写图片描述](http://img.blog.csdn.net/20170825121021364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n13.配置开机启动zookeeper\n\n![这里写图片描述](http://img.blog.csdn.net/20170825121059827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n>**注意注意** 在centos7中，/etc/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n```chmod +x /etc/rc.d/rc.local```\n\n\nOK,以上就是我们在CentOS7中安装zookeeper的全过程，做好这一切之后我们就可以在Dubbo中使用这个注册中心了，这个我们放在下一篇博客中介绍。\n', 'https://w.wallhaven.cc/full/39/wallhaven-39dmkd.jpg', '2', '1', '0', '2020-09-27 17:50:41', '2020-09-27 17:50:41');
INSERT INTO `blog` VALUES ('49', '初识MongoDB中的索引', 'MongoDB', '原创', '索引就像图书的目录一样，可以让我们快速定位到需要的内容，关系型数据库中有索引，NoSQL中当然也有，本文我们就先来简单介绍下MongoDB中的索引。  \n', '## 索引创建\n\n默认情况下，集合中的```_id```字段就是索引，我们可以通过getIndexes()方法来查看一个集合中的索引：  \n\n```\ndb.sang_collect.getIndexes()\n```  \n\n结果如下：  \n\n```\n[\n    {\n        \"v\" : 2,\n        \"key\" : {\n            \"_id\" : 1\n        },\n        \"name\" : \"_id_\",\n        \"ns\" : \"sang.sang_collect\"\n    }\n]\n```  \n\n我们看到这里只有一个索引，就是```_id```。   \n\n现在我的集合中有10000个文档，我想要查询x为1的文档，我的查询操作如下：  \n\n```\ndb.sang_collect.find({x:1})\n```  \n\n这种查询默认情况下会做全表扫描，我们可以用上篇文章介绍的explain()来查看一下查询计划，如下：  \n\n```\ndb.sang_collect.find({x:1}).explain(\"executionStats\")\n```  \n\n结果如下：  \n\n```\n{\n    \"queryPlanner\" : {\n    },\n    \"executionStats\" : {\n        \"executionSuccess\" : true,\n        \"nReturned\" : 1,\n        \"executionTimeMillis\" : 15,\n        \"totalKeysExamined\" : 0,\n        \"totalDocsExamined\" : 10000,\n        \"executionStages\" : {\n            \"stage\" : \"COLLSCAN\",\n            \"filter\" : {\n                \"x\" : {\n                    \"$eq\" : 1.0\n                }\n            },\n            \"nReturned\" : 1,\n            \"executionTimeMillisEstimate\" : 29,\n            \"works\" : 10002,\n            \"advanced\" : 1,\n            \"needTime\" : 10000,\n            \"needYield\" : 0,\n            \"saveState\" : 78,\n            \"restoreState\" : 78,\n            \"isEOF\" : 1,\n            \"invalidates\" : 0,\n            \"direction\" : \"forward\",\n            \"docsExamined\" : 10000\n        }\n    },\n    \"serverInfo\" : {\n    },\n    \"ok\" : 1.0\n}\n```  \n\n结果比较长，我摘取了关键的一部分。我们可以看到查询方式是全表扫描，一共扫描了10000个文档才查出来我要的结果。实际上我要的文档就排第二个，但是系统不知道这个集合中一共有多少个x为1的文档，所以会把全表扫描完，这种方式当然很低效，但是如果我加上limit，如下：  \n\n```\ndb.sang_collect.find({x:1}).limit(1)\n```  \n\n此时再看查询计划发现只扫描了两个文档就有结果了，但是如果我要查询x为9999的记录，那还是得把全表扫描一遍，此时，我们就可以给该字段建立索引，索引建立方式如下：  \n\n```\ndb.sang_collect.ensureIndex({x:1})\n```  \n\n1表示升序，-1表示降序。当我们给x字段建立索引之后，再根据x字段去查询，速度就非常快了，我们看下面这个查询操作的执行计划：  \n\n```\ndb.sang_collect.find({x:9999}).explain(\"executionStats\")\n```  \n\n这个查询计划过长我就不贴出来了，我们可以重点关注查询要耗费的时间大幅度下降。  \n\n此时调用getIndexes()方法可以看到我们刚刚创建的索引，如下：  \n\n```\n[\n    {\n        \"v\" : 2,\n        \"key\" : {\n            \"_id\" : 1\n        },\n        \"name\" : \"_id_\",\n        \"ns\" : \"sang.sang_collect\"\n    },\n    {\n        \"v\" : 2,\n        \"key\" : {\n            \"x\" : 1.0\n        },\n        \"name\" : \"x_1\",\n        \"ns\" : \"sang.sang_collect\"\n    }\n]\n```  \n我们看到每个索引都有一个名字，默认的索引名字为```字段名_排序值```，当然我们也可以在创建索引时自定义索引名字，如下：  \n\n```\ndb.sang_collect.ensureIndex({x:1},{name:\"myfirstindex\"})\n```  \n\n此时创建好的索引如下：  \n\n```\n{\n    \"v\" : 2,\n    \"key\" : {\n        \"x\" : 1.0\n    },\n    \"name\" : \"myfirstindex\",\n    \"ns\" : \"sang.sang_collect\"\n}\n```  \n\n当然索引在创建的过程中还有许多其他可选参数，如下：  \n\n```\ndb.sang_collect.ensureIndex({x:1},{name:\"myfirstindex\",dropDups:true,background:true,unique:true,sparse:true,v:1,weights:99999})\n```  \n\n关于这里的参数，我说一下：  \n\n>1.name表示索引的名称  \n>2.dropDups表示创建唯一性索引时如果出现重复，则将重复的删除，只保留第一个  \n>3.background是否在后台创建索引，在后台创建索引不影响数据库当前的操作，默认为false  \n>4.unique是否创建唯一索引，默认false  \n>5.sparse对文档中不存在的字段是否不起用索引，默认false\n>6.v表示索引的版本号，默认为2  \n>7.weights表示索引的权重  \n\n此时创建好的索引如下：  \n\n```\n{\n    \"v\" : 1,\n    \"unique\" : true,\n    \"key\" : {\n        \"x\" : 1.0\n    },\n    \"name\" : \"myfirstindex\",\n    \"ns\" : \"sang.sang_collect\",\n    \"background\" : true,\n    \"sparse\" : true,\n    \"weights\" : 99999.0\n}\n```  \n\n## 查看索引\n\n上文我们介绍了getIndexes()可以用来查看索引，我们还可以通过totalIndexSize()来查看索引的大小，如下：  \n\n```\ndb.sang_collect.totalIndexSize()\n```  \n\n## 删除索引\n\n我们可以按名称删除索引，如下：  \n\n```\ndb.sang_collect.dropIndex(\"xIndex\")\n```  \n\n表示删除一个名为xIndex的索引，当然我们也可以删除所有索引，如下：  \n\n```\ndb.sang_collect.dropIndexes()\n```  \n\n## 总结\n\n索引是个好东西，可以有效的提高查询速度，但是索引会降低插入、更新和删除的速度，因为这些操作不仅要更新文档，还要更新索引，MongoDB限制每个集合上最多有64个索引，我们在创建索引时要仔细斟酌索引的字段。   \n\n好了，MongoDB中的索引入门我们就说到这里，小伙伴们有问题欢迎留言讨论。   \n\n参考资料：  \n\n1.《MongoDB权威指南第2版》  ', 'https://w.wallhaven.cc/full/2e/wallhaven-2eroxm.jpg', '3', '1', '0', '2020-09-27 17:52:51', '2020-09-27 17:52:51');
INSERT INTO `blog` VALUES ('50', 'SpringBoot+SpringSecurity处理Ajax登录请求', 'SpringBoot', '转载', '遇到了这样一个问题：前后端分离，前端用Vue来做，所有的数据请求都使用vue-resource，没有使用表单，因此数据交互都是使用JSON，后台使用Spring Boot，权限验证使用了Spring Security，因为之前用Spring Security都是处理页面的，这次单纯处理Ajax请求，因此记录下遇到的一些问题。这里的解决方案不仅适用于Ajax请求，也可以解决移动端请求验证。   \n', '### 创建工程\n\n首先我们需要创建一个Spring Boot工程，创建时需要引入Web、Spring Security、MySQL和MyBatis(数据库框架其实随意，我这里使用MyBatis)，创建好之后，依赖文件如下：  \n\n```\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>1.3.1</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>commons-codec</groupId>\n    <artifactId>commons-codec</artifactId>\n    <version>1.11</version>\n</dependency>\n```  \n\n注意最后一个**commons-codec**依赖是我手动加入进来的，这是一个Apache的开源项目，可以用来生成MD5消息摘要，我在后文中将对密码进行简单的处理。  \n\n### 创建数据库并配置\n\n为了简化逻辑，我这里创建了三个表，分别是用户表、角色表、用户角色关联表，如下：  \n\n![p271]()  \n\n接下来我们需要在application.properties中对自己的数据库进行简单的配置，这里各位小伙伴视自己的具体情况而定。  \n\n```\nspring.datasource.url=jdbc:mysql:///vueblog\nspring.datasource.username=root\nspring.datasource.password=123\n```  \n\n### 构造实体类\n\n这里主要是指构造用户类，这里的用户类比较特殊，必须实现UserDetails接口，如下：  \n\n```\npublic class User implements UserDetails {\n    private Long id;\n    private String username;\n    private String password;\n    private String nickname;\n    private boolean enabled;\n    private List<Role> roles;\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    @Override\n    public List<GrantedAuthority> getAuthorities() {\n        List<GrantedAuthority> authorities = new ArrayList<>();\n        for (Role role : roles) {\n            authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getName()));\n        }\n        return authorities;\n    }\n    //getter/setter省略...\n}\n```  \n\n实现了UserDetails接口之后，该接口中有几个方法需要我们实现，四个返回Boolean的方法都是见名知意，enabled表示档期账户是否启用，这个我数据库中确实有该字段，因此根据查询结果返回，其他的为了简单期间都直接返回true，getAuthorities方法返回当前用户的角色信息，用户的角色其实就是roles中的数据，将roles中的数据转换为List<GrantedAuthority>之后返回即可，**这里有一个要注意的地方，由于我在数据库中存储的角色名都是诸如‘超级管理员’、‘普通用户’之类的，并不是以```ROLE_```这样的字符开始的，因此需要在这里手动加上```ROLE_```,切记**。  \n\n另外还有一个Role实体类，比较简单，按照数据库的字段创建即可，这里不再赘述。  \n\n### 创建UserService\n\n这里的UserService也比较特殊，需要实现UserDetailsService接口，如下：  \n\n```\n@Service\npublic class UserService implements UserDetailsService {\n    @Autowired\n    UserMapper userMapper;\n    @Autowired\n    RolesMapper rolesMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        User user = userMapper.loadUserByUsername(s);\n        if (user == null) {\n            //避免返回null，这里返回一个不含有任何值的User对象，在后期的密码比对过程中一样会验证失败\n            return new User();\n        }\n        //查询用户的角色信息，并返回存入user中\n        List<Role> roles = rolesMapper.getRolesByUid(user.getId());\n        user.setRoles(roles);\n        return user;\n    }\n}\n```  \n\n实现了UserDetailsService接口之后，我们需要实现该接口中的loadUserByUsername方法，即根据用户名查询用户。这里注入了两个MyBatis中的Mapper，UserMapper用来查询用户，RolesMapper用来查询角色。在loadUserByUsername方法中，首先根据传入的参数（参数就是用户登录时输入的用户名）去查询用户，如果查到的用户为null，可以直接抛一个UsernameNotFoundException异常，但是我为了处理方便，返回了一个没有任何值的User对象，这样在后面的密码比对过程中一样会发现登录失败的（这里大家根据自己的业务需求调整即可），如果查到的用户不为null，此时我们根据查到的用户id再去查询该用户的角色，并将查询结果放入到user对象中，这个查询结果将在user对象的getAuthorities方法中用上。  \n\n### Security配置\n\n我们先来看一下我的Security配置，然后我再来一一解释：  \n\n```\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    UserService userService;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userService).passwordEncoder(new PasswordEncoder() {\n            @Override\n            public String encode(CharSequence charSequence) {\n                return DigestUtils.md5DigestAsHex(charSequence.toString().getBytes());\n            }\n\n            /**\n             * @param charSequence 明文\n             * @param s 密文\n             * @return\n             */\n            @Override\n            public boolean matches(CharSequence charSequence, String s) {\n                return s.equals(DigestUtils.md5DigestAsHex(charSequence.toString().getBytes()));\n            }\n        });\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .antMatchers(\"/admin/**\").hasRole(\"超级管理员\")\n                .anyRequest().authenticated()//其他的路径都是登录后即可访问\n                .and().formLogin().loginPage(\"/login_page\").successHandler(new AuthenticationSuccessHandler() {\n            @Override\n            public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {\n                httpServletResponse.setContentType(\"application/json;charset=utf-8\");\n                PrintWriter out = httpServletResponse.getWriter();\n                out.write(\"{\\\"status\\\":\\\"ok\\\",\\\"msg\\\":\\\"登录成功\\\"}\");\n                out.flush();\n                out.close();\n            }\n        })\n                .failureHandler(new AuthenticationFailureHandler() {\n                    @Override\n                    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {\n                        httpServletResponse.setContentType(\"application/json;charset=utf-8\");\n                        PrintWriter out = httpServletResponse.getWriter();\n                        out.write(\"{\\\"status\\\":\\\"error\\\",\\\"msg\\\":\\\"登录失败\\\"}\");\n                        out.flush();\n                        out.close();\n                    }\n                }).loginProcessingUrl(\"/login\")\n                .usernameParameter(\"username\").passwordParameter(\"password\").permitAll()\n                .and().logout().permitAll().and().csrf().disable();\n    }\n\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web.ignoring().antMatchers(\"/reg\");\n    }\n}\n```  \n\n这是我们配置的核心，小伙伴们听我一一道来：   \n\n1.首先这是一个配置类，因此记得加上@Configuration注解，又因为这是Spring Security的配置，因此记得继承WebSecurityConfigurerAdapter。  \n2.将刚刚创建好的UserService注入进来，一会我们要用。  \n3.configure(AuthenticationManagerBuilder auth)方法中用来配置我们的认证方式，在auth.userDetailsService()方法中传入userService，这样userService中的loadUserByUsername方法在用户登录时将会被自动调用。后面的passwordEncoder是可选项，可写可不写，因为我是将用户的明文密码生成了MD5消息摘要后存入数据库的，因此在登录时也需要对明文密码进行处理，所以就加上了passwordEncoder，加上passwordEncoder后，直接new一个PasswordEncoder匿名内部类即可，这里有两个方法要实现，看名字就知道方法的含义，第一个方法encode显然是对明文进行加密，这里我使用了MD5消息摘要，具体的实现方法是由commons-codec依赖提供的；第二个方法matches是密码的比对，两个参数，第一个参数是明文密码，第二个是密文，这里只需要对明文加密后和密文比较即可（小伙伴如果对此感兴趣可以继续考虑密码加盐）。   \n4.configure(HttpSecurity http)用来配置我们的认证规则等，authorizeRequests方法表示开启了认证规则配置，antMatchers(\"/admin/**\").hasRole(\"超级管理员\")表示```/admin/**```的路径需要有‘超级管理员’角色的用户才能访问，我在网上看到小伙伴对hasRole方法中要不要加```ROLE_```前缀有疑问,这里是不要加的，如果用hasAuthority方法才需要加。anyRequest().authenticated()表示其他所有路径都是需要认证/登录后才能访问。接下来我们配置了登录页面为login_page，登录处理路径为/login，登录用户名为username，密码为password，并配置了这些路径都可以直接访问，注销登陆也可以直接访问，最后关闭csrf。在successHandler中，使用response返回登录成功的json即可，切记不可以使用defaultSuccessUrl，defaultSuccessUrl是只登录成功后重定向的页面，failureHandler也是由于相同的原因不使用failureUrl。    \n5.configure(WebSecurity web)方法中我配置了一些过滤规则，不赘述。  \n6.另外，对于静态文件，如```/images/**```、```/css/**```、```/js/**```这些路径，这里默认都是不拦截的。  \n\n### Controller\n\n最后来看看我们的Controller，如下：  \n\n```\n@RestController\npublic class LoginRegController {\n\n    /**\n     * 如果自动跳转到这个页面，说明用户未登录，返回相应的提示即可\n     * <p>\n     * 如果要支持表单登录，可以在这个方法中判断请求的类型，进而决定返回JSON还是HTML页面\n     *\n     * @return\n     */\n    @RequestMapping(\"/login_page\")\n    public RespBean loginPage() {\n        return new RespBean(\"error\", \"尚未登录，请登录!\");\n    }\n}\n```  \n\n这个Controller整体来说还是比较简单的，RespBean一个响应bean，返回一段简单的json，不赘述，这里需要小伙伴注意的是```login_page```,我们配置的登录页面是一个```login_page```,但实际上```login_page```并不是一个页面，而是返回一段JSON，这是因为当我未登录就去访问其他页面时Spring Security会自动跳转到到```login_page```页面，但是在Ajax请求中，不需要这种跳转，我要的只是是否登录的提示，所以这里返回json即可。  \n\n### 测试\n', 'https://w.wallhaven.cc/full/ox/wallhaven-oxzk8m.jpg', '7', '1', '0', '2020-09-27 17:54:53', '2020-09-27 17:54:53');

-- ----------------------------
-- Table structure for foreignkey
-- ----------------------------
DROP TABLE IF EXISTS `foreignkey`;
CREATE TABLE `foreignkey` (
  `id` int(12) NOT NULL AUTO_INCREMENT,
  `label` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `label` (`label`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of foreignkey
-- ----------------------------
INSERT INTO `foreignkey` VALUES ('1', '管理员', '2020-09-16 13:04:04', '2020-09-16 13:04:04');
INSERT INTO `foreignkey` VALUES ('2', '测试类', '2020-09-16 13:29:55', '2020-09-16 13:29:55');
INSERT INTO `foreignkey` VALUES ('3', '排错类', '2020-09-16 15:17:54', '2020-09-16 15:17:54');
INSERT INTO `foreignkey` VALUES ('6', 'Markdown', '2020-09-19 08:38:38', '2020-09-19 08:38:38');
INSERT INTO `foreignkey` VALUES ('7', '笔记', '2020-09-19 08:46:32', '2020-09-19 08:46:32');
INSERT INTO `foreignkey` VALUES ('8', 'Mybatis-plus', '2020-09-19 08:50:17', '2020-09-19 08:50:17');
INSERT INTO `foreignkey` VALUES ('9', 'JSP', '2020-09-19 08:53:59', '2020-09-19 08:53:59');
INSERT INTO `foreignkey` VALUES ('10', 'SpringBoot', '2020-09-19 08:57:25', '2020-09-19 08:57:25');
INSERT INTO `foreignkey` VALUES ('11', '常见手撕模板题', '2020-09-19 09:05:31', '2020-09-19 09:05:31');
INSERT INTO `foreignkey` VALUES ('12', 'SpringCloud', '2020-09-19 09:12:52', '2020-09-19 09:12:52');
INSERT INTO `foreignkey` VALUES ('13', 'Linux', '2020-09-27 17:48:55', '2020-09-27 17:48:55');
INSERT INTO `foreignkey` VALUES ('14', 'MongoDB', '2020-09-27 17:51:30', '2020-09-27 17:51:30');

-- ----------------------------
-- Table structure for message
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` int(12) NOT NULL AUTO_INCREMENT,
  `nickName` varchar(255) NOT NULL,
  `userName` varchar(255) NOT NULL DEFAULT '游客',
  `email` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES ('1', '管理员', 'admin', 'incytom@qq.com', '测试！\r\n测试！\r\n测试！', '2020-09-09 14:04:42');
INSERT INTO `message` VALUES ('2', '管理员', 'admin', 'incytom@qq.com', '再次测试！\r\n再次测试！\r\n再次测试！', '2020-09-09 14:25:40');
INSERT INTO `message` VALUES ('3', '管理员', 'admin', 'incytom@qq.com', '第五次测试！\r\n第五次测试！\r\n第五次测试！', '2020-09-09 14:32:45');
INSERT INTO `message` VALUES ('4', '管理员', 'admin', 'qweqweqwe@qq.com', '游客测试', '2020-09-09 15:20:56');
INSERT INTO `message` VALUES ('5', '管理员', 'admin', 'qweqweqwe@qq.com', '游客测试', '2020-09-09 15:22:54');
INSERT INTO `message` VALUES ('6', '管理员', 'admin', 'qweqweqwe@qq.com', '最终测试确认', '2020-09-09 15:27:32');
INSERT INTO `message` VALUES ('7', '汤姆', '游客', 'incytom@qq.com', '测试', '2020-09-16 17:13:22');
INSERT INTO `message` VALUES ('8', 'tom', '游客', 'incytom@qq.com', '最后测试', '2020-09-16 18:50:18');
INSERT INTO `message` VALUES ('9', '啊', '游客', 'incytom@qq.com', '我是猪', '2020-09-16 20:22:06');
INSERT INTO `message` VALUES ('10', 'Tom', '游客', 'incytom@qq.com', '第十次测试', '2020-09-17 09:21:48');
INSERT INTO `message` VALUES ('11', 'Tom', '游客', 'incutom@qq.com', '最终测试！', '2020-09-19 10:44:30');
INSERT INTO `message` VALUES ('12', 'Tom', '游客', 'incutom@qq.com', '打包成功！', '2020-09-23 18:25:50');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `nickName` varchar(255) NOT NULL DEFAULT '管理员',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'admin', 'admin', '管理员', '2020-09-08 16:38:05', '2020-09-08 16:38:05');
INSERT INTO `user` VALUES ('2', 'Tom', '123456', '管理员', '2020-09-17 20:34:08', '2020-09-17 20:34:08');
